{"version":3,"file":"/Users/usermaitha/trademaster/libs/lib-external-opencensus-node/src/stats/types.ts","sources":["/Users/usermaitha/trademaster/libs/lib-external-opencensus-node/src/stats/types.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;;AA2IH;;;GAGG;AACH,IAAY,WAOX;AAPD,WAAY,WAAW;IACrB,yBAAU,CAAA;IACV,0BAAW,CAAA;IACX,2BAAY,CAAA;IACZ,wBAAS,CAAA;IACT,wBAAS,CAAA;IACT,wBAAS,CAAA;AACX,CAAC,EAPW,WAAW,GAAX,mBAAW,KAAX,mBAAW,QAOtB;AAED,0EAA0E;AAC1E,IAAY,WAGX;AAHD,WAAY,WAAW;IACrB,8BAAe,CAAA;IACf,gCAAiB,CAAA;AACnB,CAAC,EAHW,WAAW,GAAX,mBAAW,KAAX,mBAAW,QAGtB;AAkED;;;GAGG;AACH,IAAY,eAKX;AALD,WAAY,eAAe;IACzB,uDAAS,CAAA;IACT,mDAAO,CAAA;IACP,iEAAc,CAAA;IACd,qEAAgB,CAAA;AAClB,CAAC,EALW,eAAe,GAAf,uBAAe,KAAf,uBAAe,QAK1B","sourcesContent":["/**\n * Copyright 2018, OpenCensus Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { StatsEventListener } from '../exporters/types';\nimport { Metric } from '../metrics/export/types';\nimport { TagMap } from '../tags/tag-map';\nimport { TagKey, TagValue } from '../tags/types';\n\n/** Default type for functions */\n// tslint:disable:no-any\ntype Func<T> = (...args: any[]) => T;\n\n/** Main interface for stats. */\nexport interface Stats {\n  /**\n   * Creates a view.\n   * @param name The view name\n   * @param measure The view measure\n   * @param aggregation The view aggregation type\n   * @param tagKeys The view columns (tag keys)\n   * @param description The view description\n   * @param bucketBoundaries The view bucket boundaries for a distribution\n   *     aggregation type\n   */\n  createView(\n    name: string,\n    measure: Measure,\n    aggregation: AggregationType,\n    tagKeys: TagKey[],\n    description: string,\n    bucketBoundaries?: number[]\n  ): View;\n\n  /**\n   * Registers a view to listen to new measurements in its measure.\n   * @param view The view to be registered\n   */\n  registerView(view: View): void;\n\n  /**\n   * Creates a measure of type Double.\n   * @param name The measure name\n   * @param unit The measure unit\n   * @param description The measure description\n   */\n  createMeasureDouble(\n    name: string,\n    unit: MeasureUnit,\n    description?: string\n  ): Measure;\n\n  /**\n   * Creates a measure of type Int64. Values must be integers up to\n   * Number.MAX_SAFE_INTERGER.\n   * @param name The measure name\n   * @param unit The measure unit\n   * @param description The measure description\n   */\n  createMeasureInt64(\n    name: string,\n    unit: MeasureUnit,\n    description?: string\n  ): Measure;\n\n  /**\n   * Updates all views with the new measurements.\n   * @param measurements A list of measurements to record\n   * @param tags optional The tags to which the value is applied.\n   *     tags could either be explicitly passed to the method, or implicitly\n   *     read from current execution context.\n   * @param attachments optional The contextual information associated with an\n   *     example value. The contextual information is represented as key - value\n   *     string pairs.\n   */\n  record(\n    measurements: Measurement[],\n    tags?: TagMap,\n    attachments?: { [key: string]: string }\n  ): void;\n\n  /**\n   * Remove all registered Views and exporters from the stats.\n   */\n  clear(): void;\n\n  /**\n   * Gets a collection of produced Metric`s to be exported.\n   * @returns The List of metrics.\n   */\n  getMetrics(): Metric[];\n\n  /**\n   * Registers an exporter to send stats data to a service.\n   * @param exporter An stats exporter\n   */\n  registerExporter(exporter: StatsEventListener): void;\n\n  /**\n   * Unregisters an exporter. It should be called whenever the exporter is not\n   * needed anymore.\n   * @param exporter An stats exporter\n   */\n  unregisterExporter(exporter: StatsEventListener): void;\n\n  /**\n   * Enters the scope of code where the given `TagMap` is in the current context\n   * (replacing the previous `TagMap`).\n   * @param tags The TagMap to be set to the current context.\n   * @param fn Callback function.\n   * @returns The callback return.\n   */\n  withTagContext<T>(tags: TagMap, fn: Func<T>): T;\n\n  /** Gets the current tag context. */\n  getCurrentTagContext(): TagMap;\n}\n\n/**\n * Describes the type of the individual values/measurements recorded by an\n * application. It includes information such as the type of measurement, the\n * units of measurement and descriptive names for the data. This provides the\n * fundamental type used for recording data.\n */\nexport interface Measure {\n  /**\n   * A string by which the measure will be referred to, e.g.\n   * \"rpc_server_latency\". Names MUST be unique within the library.\n   */\n  readonly name: string;\n  /** Describes the measure, e.g. \"RPC latency in seconds\". */\n  readonly description?: string;\n  /**\n   * Describes the unit used for the Measure. Follows the format described by\n   * http://unitsofmeasure.org/ucum.html.\n   */\n  readonly unit: MeasureUnit;\n  /** The type used for this Measure. */\n  readonly type: MeasureType;\n}\n\n/**\n * Describes the unit used for the Measure. Should follows the format described\n * by http://unitsofmeasure.org/ucum.html.\n */\nexport enum MeasureUnit {\n  UNIT = '1', // for general counts\n  BYTE = 'by', // bytes\n  KBYTE = 'kb', // Kbytes\n  SEC = 's', // seconds\n  MS = 'ms', // millisecond\n  NS = 'ns', // nanosecond\n}\n\n/** Describes the types of a Measure. It can be Int64 or a Double type. */\nexport enum MeasureType {\n  INT64 = 'INT64',\n  DOUBLE = 'DOUBLE',\n}\n\n/** Describes a data point to be collected for a Measure. */\nexport interface Measurement {\n  /** The measure to which the value is applied */\n  readonly measure: Measure;\n  /**\n   * The recorded value. If the measure has type INT64, value must be an integer\n   * up to Number.MAX_SAFE_INTERGER.\n   */\n  readonly value: number;\n}\n\n/**\n * Defines how individual measurements are broken down by tags and aggregated.\n */\nexport interface View {\n  /**\n   * A string by which the View will be referred to, e.g. \"rpc_latency\". Names\n   * MUST be unique within the library.\n   */\n  readonly name: string;\n  /** Describes the view, e.g. \"RPC latency distribution\" */\n  readonly description: string;\n  /** The Measure to which this view is applied. */\n  readonly measure: Measure;\n  /**\n   * An Aggregation describes how data collected is aggregated.\n   * There are four aggregation types: count, sum, lastValue and distirbution.\n   */\n  readonly aggregation: AggregationType;\n  /** The start time for this view */\n  readonly startTime: number;\n  /**\n   * The end time for this view - represents the last time a value was recorded\n   */\n  endTime?: number;\n  /** true if the view was registered */\n  registered: boolean;\n  /**\n   * Records a measurement in the proper view's row. This method is used by\n   * Stats. User should prefer using Stats.record() instead.\n   *\n   * Measurements with measurement type INT64 will have its value truncated.\n   * @param measurement The measurement to record\n   * @param tags The tags to which the value is applied\n   * @param attachments optional The contextual information associated with an\n   *     example value. THe contextual information is represented as key - value\n   *     string pairs.\n   */\n  recordMeasurement(\n    measurement: Measurement,\n    tags: TagMap,\n    attachments?: { [key: string]: string }\n  ): void;\n  /**\n   * Returns a snapshot of an AggregationData for that tags/labels values.\n   * @param tagValues The desired data's tag values.\n   */\n  getSnapshot(tagValues: Array<TagValue | null>): AggregationData;\n  /** Gets the view's tag keys */\n  getColumns(): TagKey[];\n  /** Gets view`s metric */\n  getMetric(start: number): Metric;\n}\n\n/**\n * Informs the type of the aggregation. It can be: count, sum, lastValue or\n * distribution.\n */\nexport enum AggregationType {\n  COUNT = 0,\n  SUM = 1,\n  LAST_VALUE = 2,\n  DISTRIBUTION = 3,\n}\n\n/** Defines how data is collected and aggregated */\nexport interface AggregationMetadata {\n  /** The aggregation type of the aggregation data */\n  readonly type: AggregationType;\n  /** The tagValues that this AggregationData collects and aggregates */\n  readonly tagValues: Array<TagValue | null>;\n  /** The latest timestamp a new data point was recorded */\n  timestamp: number;\n}\n\n/**\n * Data collected and aggregated with this AggregationData will be summed\n * up.\n */\nexport interface SumData extends AggregationMetadata {\n  type: AggregationType.SUM;\n  /** The current accumulated value */\n  value: number;\n}\n\n/**\n * This AggregationData counts the number of measurements recorded.\n */\nexport interface CountData extends AggregationMetadata {\n  type: AggregationType.COUNT;\n  /** The current counted value */\n  value: number;\n}\n\n/**\n * This AggregationData represents the last recorded value. This is useful\n * when giving support to Gauges.\n */\nexport interface LastValueData extends AggregationMetadata {\n  type: AggregationType.LAST_VALUE;\n  /** The last recorded value */\n  value: number;\n}\n\n/** This AggregationData contains a histogram of the collected values. */\nexport interface DistributionData extends AggregationMetadata {\n  type: AggregationType.DISTRIBUTION;\n  /** The first timestamp a datapoint was added */\n  readonly startTime: number;\n  /** Get the total count of all recorded values in the histogram */\n  count: number;\n  /** Sum of all recorded values in the histogram */\n  sum: number;\n  /** Get the computed mean value of all recorded values in the histogram */\n  mean: number;\n  /**\n   * Get the computed standard deviation of all recorded values in the\n   * histogram\n   */\n  stdDeviation: number;\n  /**\n   * Get the computed sum of squared deviations of all recorded values in the\n   * histogram.\n   */\n  sumOfSquaredDeviation: number;\n  /** Bucket distribution of the histogram */\n  buckets: Bucket[];\n  /** Buckets count */\n  bucketCounts?: number[];\n  /** If the distribution does not have a histogram, then omit this field. */\n  exemplars?: StatsExemplar[];\n}\n\n/**\n * Exemplars are example points that may be used to annotate aggregated\n * Distribution values. They are metadata that gives information about a\n * particular value added to a Distribution bucket.\n */\nexport interface StatsExemplar {\n  /**\n   * Value of the exemplar point. It determines which bucket the exemplar\n   * belongs to.\n   */\n  readonly value: number;\n  /** The observation (sampling) time of the above value. */\n  readonly timestamp: number;\n  /** Contextual information about the example value. */\n  readonly attachments: { [key: string]: string };\n}\n\nexport type Bucket = number;\nexport type AggregationData =\n  | SumData\n  | CountData\n  | LastValueData\n  | DistributionData;\n"]}