"use strict";/**
 * Copyright 2018, OpenCensus Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function cov_2diekf974t(){var path="/Users/usermaitha/trademaster/libs/lib-external-opencensus-node/src/metrics/export/types.ts";var hash="2bc8fb15da01750e70711385d27c8d23cdbec4d8";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/Users/usermaitha/trademaster/libs/lib-external-opencensus-node/src/metrics/export/types.ts",statementMap:{"0":{start:{line:17,column:0},end:{line:17,column:62}},"1":{start:{line:18,column:0},end:{line:18,column:38}},"2":{start:{line:31,column:0},end:{line:69,column:95}},"3":{start:{line:33,column:4},end:{line:33,column:82}},"4":{start:{line:35,column:4},end:{line:35,column:82}},"5":{start:{line:37,column:4},end:{line:37,column:84}},"6":{start:{line:44,column:4},end:{line:44,column:96}},"7":{start:{line:49,column:4},end:{line:49,column:92}},"8":{start:{line:55,column:4},end:{line:55,column:94}},"9":{start:{line:60,column:4},end:{line:60,column:106}},"10":{start:{line:68,column:4},end:{line:68,column:74}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:31,column:1},end:{line:31,column:2}},loc:{start:{line:31,column:33},end:{line:69,column:1}},line:31}},branchMap:{"0":{loc:{start:{line:69,column:26},end:{line:69,column:93}},type:"binary-expr",locations:[{start:{line:69,column:26},end:{line:69,column:54}},{start:{line:69,column:59},end:{line:69,column:92}}],line:69}},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0},f:{"0":0},b:{"0":[0,0]},inputSourceMap:{version:3,file:"/Users/usermaitha/trademaster/libs/lib-external-opencensus-node/src/metrics/export/types.ts",sources:["/Users/usermaitha/trademaster/libs/lib-external-opencensus-node/src/metrics/export/types.ts"],names:[],mappings:";AAAA;;;;;;;;;;;;;;GAcG;;;AAsCH;;;;;;;;;;GAUG;AACH,IAAY,oBAsCX;AAtCD,WAAY,oBAAoB;IAC9B,qCAAqC;IACrC,6EAAW,CAAA;IACX,wDAAwD;IACxD,6EAAW,CAAA;IACX,+DAA+D;IAC/D,+EAAY,CAAA;IACZ;;;;;OAKG;IACH,2FAAkB,CAAA;IAClB;;;OAGG;IACH,uFAAgB,CAAA;IAChB;;;;OAIG;IACH,yFAAiB,CAAA;IACjB;;;OAGG;IACH,qGAAuB,CAAA;IACvB;;;;;;OAMG;IACH,qEAAO,CAAA;AACT,CAAC,EAtCW,oBAAoB,GAApB,4BAAoB,KAApB,4BAAoB,QAsC/B",sourcesContent:["/**\n * Copyright 2018, OpenCensus Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** Properties of a Metric which has one or more timeseries */\nexport interface Metric {\n  /**\n   * The descriptor of the Metric. This is an optimization for network wire\n   * size, from data-model perspective a Metric contains always\n   * a MetricDescriptor.\n   * In case of a streaming RPC can be sent only\n   * the first time a metric is reported to save network traffic.\n   */\n  readonly descriptor: MetricDescriptor;\n  /**\n   * One or more timeseries for a single metric, where each timeseries has\n   * one or more points.\n   */\n  readonly timeseries: TimeSeries[];\n}\n\n/** Properties of a Metric type and its schema */\nexport interface MetricDescriptor {\n  /**  The metric type, including its DNS name prefix. It must be unique. */\n  readonly name: string;\n  /**\n   * A detailed description of the metric, which can be used in documentation.\n   */\n  readonly description: string;\n  /**\n   * The unit in which the metric value is reported. Follows the format\n   * described by http://unitsofmeasure.org/ucum.html.\n   */\n  readonly unit: string;\n  /** MetricDescriptor type */\n  readonly type: MetricDescriptorType;\n  /** The label keys associated with the metric descriptor. */\n  readonly labelKeys: LabelKey[];\n}\n\n/**\n * The kind of metric. It describes how the data is reported.\n *\n * A gauge is an instantaneous measurement of a value.\n *\n * A cumulative measurement is a value accumulated over a time interval. In\n * a time series, cumulative measurements should have the same start time,\n * increasing values and increasing end times, until an event resets the\n * cumulative value to zero and sets a new start time for the following\n * points.\n */\nexport enum MetricDescriptorType {\n  /** Do not use this default value. */\n  UNSPECIFIED,\n  /** Integer gauge. The value can go both up and down. */\n  GAUGE_INT64,\n  /** Floating point gauge. The value can go both up and down. */\n  GAUGE_DOUBLE,\n  /**\n   * Distribution gauge measurement. The count and sum can go both up and\n   * down. Recorded values are always >= 0.\n   * Used in scenarios like a snapshot of time the current items in a queue\n   * have spent there.\n   */\n  GAUGE_DISTRIBUTION,\n  /**\n   * Integer cumulative measurement. The value cannot decrease, if resets\n   * then the start_time should also be reset.\n   */\n  CUMULATIVE_INT64,\n  /**\n   * Floating point cumulative measurement. The value cannot decrease, if\n   * resets then the start_time should also be reset. Recorded values are\n   * always >= 0.\n   */\n  CUMULATIVE_DOUBLE,\n  /**\n   * Distribution cumulative measurement. The count and sum cannot decrease,\n   * if resets then the start_time should also be reset.\n   */\n  CUMULATIVE_DISTRIBUTION,\n  /**\n   * Some frameworks implemented Histograms as a summary of observations\n   * (usually things like request durations and response sizes). While it\n   * also provides a total count of observations and a sum of all observed\n   * values, it calculates configurable percentiles over a sliding time\n   * window. This is not recommended, since it cannot be aggregated.\n   */\n  SUMMARY,\n}\n\n/** Properties of a LabelKey associated with a MetricDescriptor. */\nexport interface LabelKey {\n  /** The key for the label. */\n  readonly key: string;\n  /** A human-readable description of what this label key represents. */\n  readonly description: string;\n}\n\n/**\n * A collection of data points that describes the time-varying values\n * of a metric.\n */\nexport interface TimeSeries {\n  /**\n   * Must be present for cumulative metrics. The time when the cumulative value\n   * was reset to zero. Exclusive. The cumulative value is over the time\n   * interval (start_timestamp, timestamp]. If not specified, the backend can\n   * use the previous recorded value.\n   */\n  readonly startTimestamp?: Timestamp;\n  /**\n   * The set of label values that uniquely identify this timeseries. Applies to\n   * all points. The order of label values must match that of label keys in the\n   * metric descriptor.\n   */\n  readonly labelValues: LabelValue[];\n  /**\n   * The data points of this timeseries. Point.value type MUST match the\n   * MetricDescriptor.type.\n   */\n  readonly points: Point[];\n}\n\n/** The LabelValue type. null value indicates an unset. */\nexport interface LabelValue {\n  /** The value for the label. */\n  readonly value: string | null;\n}\n\n/** A timestamped measurement. */\nexport interface Point {\n  /**\n   * The moment when this point was recorded. Inclusive.\n   * If not specified, the timestamp will be decided by the backend.\n   */\n  readonly timestamp: Timestamp;\n  /**\n   * The actual point value.\n   * 64-bit integer or 64-bit double-precision floating-point number\n   * or distribution value\n   * or summary value. This is not recommended, since it cannot be aggregated.\n   */\n  readonly value: number | DistributionValue | SummaryValue;\n}\n\n/**\n * Distribution contains summary statistics for a population of values. It\n * optionally contains a histogram representing the distribution of those\n * values across a set of buckets.\n */\nexport interface DistributionValue {\n  /**\n   * The number of values in the population. Must be non-negative. This value\n   * must equal the sum of the values in bucket_counts if a histogram is\n   * provided.\n   */\n  readonly count: number;\n  /**\n   * The sum of the values in the population. If count is zero then this field\n   * must be zero.\n   */\n  readonly sum: number;\n  /**\n   * The sum of squared deviations from the mean of the values in the\n   * population. For values x_i this is:\n   *\n   *     Sum[i=1..n]((x_i - mean)^2)\n   *\n   * Knuth, \"The Art of Computer Programming\", Vol. 2, page 323, 3rd edition\n   * describes Welford's method for accumulating this sum in one pass.\n   *\n   * If count is zero then this field must be zero.\n   */\n  readonly sumOfSquaredDeviation: number;\n  /**\n   * Don't change bucket boundaries within a TimeSeries if your backend doesn't\n   * support this. To save network bandwidth this field can be sent only the\n   * first time a metric is sent when using a streaming RPC.\n   */\n  readonly bucketOptions: BucketOptions;\n  /** DistributionValue buckets */\n  readonly buckets: Bucket[];\n}\n\n/**\n * Properties of a BucketOptions.\n * A Distribution may optionally contain a histogram of the values in the\n * population. The bucket boundaries for that histogram are described by\n * BucketOptions.\n *\n * If bucket_options has no type, then there is no histogram associated with\n * the Distribution.\n */\nexport interface BucketOptions {\n  /** Bucket with explicit bounds. */\n  readonly explicit: Explicit;\n}\n\n/**\n * Properties of an Explicit.\n * Specifies a set of buckets with arbitrary upper-bounds.\n * This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket\n * index i are:\n *\n * [0, bucket_bounds[i]) for i == 0\n * [bucket_bounds[i-1], bucket_bounds[i]) for 0 < i < N-1\n * [bucket_bounds[i-1], +infinity) for i == N-1\n */\nexport interface Explicit {\n  /** The values must be strictly increasing and > 0. */\n  readonly bounds: number[];\n  // TODO: If OpenMetrics decides to support (a, b] intervals we should add\n  // support for these by defining a boolean value here which decides what\n  // type of intervals to use.\n}\n\n/** Properties of a Bucket. */\nexport interface Bucket {\n  /**\n   * The number of values in each bucket of the histogram, as described in\n   * bucket_bounds.\n   */\n  readonly count: number;\n  /**\n   * If the distribution does not have a histogram, then omit this field.\n   */\n  readonly exemplar?: Exemplar;\n}\n\n/**\n * Exemplars are example points that may be used to annotate aggregated\n * Distribution values. They are metadata that gives information about a\n * particular value added to a Distribution bucket.\n */\nexport interface Exemplar {\n  /**\n   * Value of the exemplar point. It determines which bucket the exemplar\n   * belongs to.\n   */\n  readonly value: number;\n  /** The observation (sampling) time of the above value. */\n  readonly timestamp: Timestamp;\n  /** Contextual information about the example value. */\n  readonly attachments: { [key: string]: string };\n}\n\n/**\n * The start_timestamp only applies to the count and sum in the SummaryValue.\n */\nexport interface SummaryValue {\n  /**\n   * The total number of recorded values since start_time. Optional since\n   * some systems don't expose this.\n   */\n  readonly count: number;\n  /**\n   * The total sum of recorded values since start_time. Optional since some\n   * systems don't expose this. If count is zero then this field must be zero.\n   * This field must be unset if the sum is not available.\n   */\n  readonly sum: number;\n  /** Values calculated over an arbitrary time window. */\n  // TODO: Change it to required when Exemplar functionality will be added.\n  readonly snapshot?: Snapshot;\n}\n\n/**\n * The values in this message can be reset at arbitrary unknown times, with\n * the requirement that all of them are reset at the same time.\n */\nexport interface Snapshot {\n  /**\n   * The number of values in the snapshot. Optional since some systems don't\n   * expose this.\n   */\n  readonly count: number;\n  /**\n   * The sum of values in the snapshot. Optional since some systems don't\n   * expose this. If count is zero then this field must be zero or not set\n   * (if not supported).\n   */\n  readonly sum: number;\n  /**\n   * A list of values at different percentiles of the distribution calculated\n   * from the current snapshot. The percentiles must be strictly increasing.\n   */\n  readonly percentileValues: ValueAtPercentile[];\n}\n\n/**\n * Represents the value at a given percentile of a distribution.\n */\nexport interface ValueAtPercentile {\n  /** The percentile of a distribution. Must be in the interval (0.0, 100.0]. */\n  readonly percentile: number;\n  /** The value at the given percentile of a distribution. */\n  readonly value: number;\n}\n\nexport interface Timestamp {\n  /**\n   * Represents seconds of UTC time since Unix epoch\n   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n   * 9999-12-31T23:59:59Z inclusive.\n   */\n  seconds: number | null;\n  /**\n   * Non-negative fractions of a second at nanosecond resolution. Negative\n   * second values with fractions must still have non-negative nanos values\n   * that count forward in time. Must be from 0 to 999,999,999\n   * inclusive.\n   */\n  nanos: number | null;\n}\n\n/**\n * Keeps a set of MetricProducer that is used by exporters to determine the\n * metrics that need to be exported.\n */\nexport interface MetricProducerManager {\n  /** Adds the MetricProducer to the manager */\n  add(metricProducer: MetricProducer): void;\n  /** Removes the MetricProducer to the manager */\n  remove(metricProducer: MetricProducer): void;\n  /** Clears all MetricProducers */\n  removeAll(): void;\n  /** Gets all registered MetricProducers that should be exported */\n  getAllMetricProducer(): Set<MetricProducer>;\n}\n\n/**\n * A MetricProducer producer that can be registered for exporting using\n * MetricProducerManager.\n */\nexport interface MetricProducer {\n  /** Gets a collection of produced Metric`s to be exported */\n  getMetrics(): Metric[];\n}\n"]},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"2bc8fb15da01750e70711385d27c8d23cdbec4d8"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
cov_2diekf974t=function(){return actualCoverage;};}return actualCoverage;}cov_2diekf974t();cov_2diekf974t().s[0]++;Object.defineProperty(exports,"__esModule",{value:true});cov_2diekf974t().s[1]++;exports.MetricDescriptorType=void 0;/**
 * The kind of metric. It describes how the data is reported.
 *
 * A gauge is an instantaneous measurement of a value.
 *
 * A cumulative measurement is a value accumulated over a time interval. In
 * a time series, cumulative measurements should have the same start time,
 * increasing values and increasing end times, until an event resets the
 * cumulative value to zero and sets a new start time for the following
 * points.
 */var MetricDescriptorType;cov_2diekf974t().s[2]++;(function(MetricDescriptorType){cov_2diekf974t().f[0]++;cov_2diekf974t().s[3]++;/** Do not use this default value. */MetricDescriptorType[MetricDescriptorType["UNSPECIFIED"]=0]="UNSPECIFIED";/** Integer gauge. The value can go both up and down. */cov_2diekf974t().s[4]++;MetricDescriptorType[MetricDescriptorType["GAUGE_INT64"]=1]="GAUGE_INT64";/** Floating point gauge. The value can go both up and down. */cov_2diekf974t().s[5]++;MetricDescriptorType[MetricDescriptorType["GAUGE_DOUBLE"]=2]="GAUGE_DOUBLE";/**
     * Distribution gauge measurement. The count and sum can go both up and
     * down. Recorded values are always >= 0.
     * Used in scenarios like a snapshot of time the current items in a queue
     * have spent there.
     */cov_2diekf974t().s[6]++;MetricDescriptorType[MetricDescriptorType["GAUGE_DISTRIBUTION"]=3]="GAUGE_DISTRIBUTION";/**
     * Integer cumulative measurement. The value cannot decrease, if resets
     * then the start_time should also be reset.
     */cov_2diekf974t().s[7]++;MetricDescriptorType[MetricDescriptorType["CUMULATIVE_INT64"]=4]="CUMULATIVE_INT64";/**
     * Floating point cumulative measurement. The value cannot decrease, if
     * resets then the start_time should also be reset. Recorded values are
     * always >= 0.
     */cov_2diekf974t().s[8]++;MetricDescriptorType[MetricDescriptorType["CUMULATIVE_DOUBLE"]=5]="CUMULATIVE_DOUBLE";/**
     * Distribution cumulative measurement. The count and sum cannot decrease,
     * if resets then the start_time should also be reset.
     */cov_2diekf974t().s[9]++;MetricDescriptorType[MetricDescriptorType["CUMULATIVE_DISTRIBUTION"]=6]="CUMULATIVE_DISTRIBUTION";/**
     * Some frameworks implemented Histograms as a summary of observations
     * (usually things like request durations and response sizes). While it
     * also provides a total count of observations and a sum of all observed
     * values, it calculates configurable percentiles over a sliding time
     * window. This is not recommended, since it cannot be aggregated.
     */cov_2diekf974t().s[10]++;MetricDescriptorType[MetricDescriptorType["SUMMARY"]=7]="SUMMARY";})(MetricDescriptorType=(cov_2diekf974t().b[0][0]++,exports.MetricDescriptorType)||(cov_2diekf974t().b[0][1]++,exports.MetricDescriptorType={}));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL3VzZXJtYWl0aGEvdHJhZGVtYXN0ZXIvbGlicy9saWItZXh0ZXJuYWwtb3BlbmNlbnN1cy1ub2RlL3NyYy9tZXRyaWNzL2V4cG9ydC90eXBlcy50cyIsInNvdXJjZXMiOlsiL1VzZXJzL3VzZXJtYWl0aGEvdHJhZGVtYXN0ZXIvbGlicy9saWItZXh0ZXJuYWwtb3BlbmNlbnN1cy1ub2RlL3NyYy9tZXRyaWNzL2V4cG9ydC90eXBlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7O0dBY0c7OztBQXNDSDs7Ozs7Ozs7OztHQVVHO0FBQ0gsSUFBWSxvQkFzQ1g7QUF0Q0QsV0FBWSxvQkFBb0I7SUFDOUIscUNBQXFDO0lBQ3JDLDZFQUFXLENBQUE7SUFDWCx3REFBd0Q7SUFDeEQsNkVBQVcsQ0FBQTtJQUNYLCtEQUErRDtJQUMvRCwrRUFBWSxDQUFBO0lBQ1o7Ozs7O09BS0c7SUFDSCwyRkFBa0IsQ0FBQTtJQUNsQjs7O09BR0c7SUFDSCx1RkFBZ0IsQ0FBQTtJQUNoQjs7OztPQUlHO0lBQ0gseUZBQWlCLENBQUE7SUFDakI7OztPQUdHO0lBQ0gscUdBQXVCLENBQUE7SUFDdkI7Ozs7OztPQU1HO0lBQ0gscUVBQU8sQ0FBQTtBQUNULENBQUMsRUF0Q1csb0JBQW9CLEdBQXBCLDRCQUFvQixLQUFwQiw0QkFBb0IsUUFzQy9CIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAxOCwgT3BlbkNlbnN1cyBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogUHJvcGVydGllcyBvZiBhIE1ldHJpYyB3aGljaCBoYXMgb25lIG9yIG1vcmUgdGltZXNlcmllcyAqL1xuZXhwb3J0IGludGVyZmFjZSBNZXRyaWMge1xuICAvKipcbiAgICogVGhlIGRlc2NyaXB0b3Igb2YgdGhlIE1ldHJpYy4gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gZm9yIG5ldHdvcmsgd2lyZVxuICAgKiBzaXplLCBmcm9tIGRhdGEtbW9kZWwgcGVyc3BlY3RpdmUgYSBNZXRyaWMgY29udGFpbnMgYWx3YXlzXG4gICAqIGEgTWV0cmljRGVzY3JpcHRvci5cbiAgICogSW4gY2FzZSBvZiBhIHN0cmVhbWluZyBSUEMgY2FuIGJlIHNlbnQgb25seVxuICAgKiB0aGUgZmlyc3QgdGltZSBhIG1ldHJpYyBpcyByZXBvcnRlZCB0byBzYXZlIG5ldHdvcmsgdHJhZmZpYy5cbiAgICovXG4gIHJlYWRvbmx5IGRlc2NyaXB0b3I6IE1ldHJpY0Rlc2NyaXB0b3I7XG4gIC8qKlxuICAgKiBPbmUgb3IgbW9yZSB0aW1lc2VyaWVzIGZvciBhIHNpbmdsZSBtZXRyaWMsIHdoZXJlIGVhY2ggdGltZXNlcmllcyBoYXNcbiAgICogb25lIG9yIG1vcmUgcG9pbnRzLlxuICAgKi9cbiAgcmVhZG9ubHkgdGltZXNlcmllczogVGltZVNlcmllc1tdO1xufVxuXG4vKiogUHJvcGVydGllcyBvZiBhIE1ldHJpYyB0eXBlIGFuZCBpdHMgc2NoZW1hICovXG5leHBvcnQgaW50ZXJmYWNlIE1ldHJpY0Rlc2NyaXB0b3Ige1xuICAvKiogIFRoZSBtZXRyaWMgdHlwZSwgaW5jbHVkaW5nIGl0cyBETlMgbmFtZSBwcmVmaXguIEl0IG11c3QgYmUgdW5pcXVlLiAqL1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBIGRldGFpbGVkIGRlc2NyaXB0aW9uIG9mIHRoZSBtZXRyaWMsIHdoaWNoIGNhbiBiZSB1c2VkIGluIGRvY3VtZW50YXRpb24uXG4gICAqL1xuICByZWFkb25seSBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHVuaXQgaW4gd2hpY2ggdGhlIG1ldHJpYyB2YWx1ZSBpcyByZXBvcnRlZC4gRm9sbG93cyB0aGUgZm9ybWF0XG4gICAqIGRlc2NyaWJlZCBieSBodHRwOi8vdW5pdHNvZm1lYXN1cmUub3JnL3VjdW0uaHRtbC5cbiAgICovXG4gIHJlYWRvbmx5IHVuaXQ6IHN0cmluZztcbiAgLyoqIE1ldHJpY0Rlc2NyaXB0b3IgdHlwZSAqL1xuICByZWFkb25seSB0eXBlOiBNZXRyaWNEZXNjcmlwdG9yVHlwZTtcbiAgLyoqIFRoZSBsYWJlbCBrZXlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWV0cmljIGRlc2NyaXB0b3IuICovXG4gIHJlYWRvbmx5IGxhYmVsS2V5czogTGFiZWxLZXlbXTtcbn1cblxuLyoqXG4gKiBUaGUga2luZCBvZiBtZXRyaWMuIEl0IGRlc2NyaWJlcyBob3cgdGhlIGRhdGEgaXMgcmVwb3J0ZWQuXG4gKlxuICogQSBnYXVnZSBpcyBhbiBpbnN0YW50YW5lb3VzIG1lYXN1cmVtZW50IG9mIGEgdmFsdWUuXG4gKlxuICogQSBjdW11bGF0aXZlIG1lYXN1cmVtZW50IGlzIGEgdmFsdWUgYWNjdW11bGF0ZWQgb3ZlciBhIHRpbWUgaW50ZXJ2YWwuIEluXG4gKiBhIHRpbWUgc2VyaWVzLCBjdW11bGF0aXZlIG1lYXN1cmVtZW50cyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBzdGFydCB0aW1lLFxuICogaW5jcmVhc2luZyB2YWx1ZXMgYW5kIGluY3JlYXNpbmcgZW5kIHRpbWVzLCB1bnRpbCBhbiBldmVudCByZXNldHMgdGhlXG4gKiBjdW11bGF0aXZlIHZhbHVlIHRvIHplcm8gYW5kIHNldHMgYSBuZXcgc3RhcnQgdGltZSBmb3IgdGhlIGZvbGxvd2luZ1xuICogcG9pbnRzLlxuICovXG5leHBvcnQgZW51bSBNZXRyaWNEZXNjcmlwdG9yVHlwZSB7XG4gIC8qKiBEbyBub3QgdXNlIHRoaXMgZGVmYXVsdCB2YWx1ZS4gKi9cbiAgVU5TUEVDSUZJRUQsXG4gIC8qKiBJbnRlZ2VyIGdhdWdlLiBUaGUgdmFsdWUgY2FuIGdvIGJvdGggdXAgYW5kIGRvd24uICovXG4gIEdBVUdFX0lOVDY0LFxuICAvKiogRmxvYXRpbmcgcG9pbnQgZ2F1Z2UuIFRoZSB2YWx1ZSBjYW4gZ28gYm90aCB1cCBhbmQgZG93bi4gKi9cbiAgR0FVR0VfRE9VQkxFLFxuICAvKipcbiAgICogRGlzdHJpYnV0aW9uIGdhdWdlIG1lYXN1cmVtZW50LiBUaGUgY291bnQgYW5kIHN1bSBjYW4gZ28gYm90aCB1cCBhbmRcbiAgICogZG93bi4gUmVjb3JkZWQgdmFsdWVzIGFyZSBhbHdheXMgPj0gMC5cbiAgICogVXNlZCBpbiBzY2VuYXJpb3MgbGlrZSBhIHNuYXBzaG90IG9mIHRpbWUgdGhlIGN1cnJlbnQgaXRlbXMgaW4gYSBxdWV1ZVxuICAgKiBoYXZlIHNwZW50IHRoZXJlLlxuICAgKi9cbiAgR0FVR0VfRElTVFJJQlVUSU9OLFxuICAvKipcbiAgICogSW50ZWdlciBjdW11bGF0aXZlIG1lYXN1cmVtZW50LiBUaGUgdmFsdWUgY2Fubm90IGRlY3JlYXNlLCBpZiByZXNldHNcbiAgICogdGhlbiB0aGUgc3RhcnRfdGltZSBzaG91bGQgYWxzbyBiZSByZXNldC5cbiAgICovXG4gIENVTVVMQVRJVkVfSU5UNjQsXG4gIC8qKlxuICAgKiBGbG9hdGluZyBwb2ludCBjdW11bGF0aXZlIG1lYXN1cmVtZW50LiBUaGUgdmFsdWUgY2Fubm90IGRlY3JlYXNlLCBpZlxuICAgKiByZXNldHMgdGhlbiB0aGUgc3RhcnRfdGltZSBzaG91bGQgYWxzbyBiZSByZXNldC4gUmVjb3JkZWQgdmFsdWVzIGFyZVxuICAgKiBhbHdheXMgPj0gMC5cbiAgICovXG4gIENVTVVMQVRJVkVfRE9VQkxFLFxuICAvKipcbiAgICogRGlzdHJpYnV0aW9uIGN1bXVsYXRpdmUgbWVhc3VyZW1lbnQuIFRoZSBjb3VudCBhbmQgc3VtIGNhbm5vdCBkZWNyZWFzZSxcbiAgICogaWYgcmVzZXRzIHRoZW4gdGhlIHN0YXJ0X3RpbWUgc2hvdWxkIGFsc28gYmUgcmVzZXQuXG4gICAqL1xuICBDVU1VTEFUSVZFX0RJU1RSSUJVVElPTixcbiAgLyoqXG4gICAqIFNvbWUgZnJhbWV3b3JrcyBpbXBsZW1lbnRlZCBIaXN0b2dyYW1zIGFzIGEgc3VtbWFyeSBvZiBvYnNlcnZhdGlvbnNcbiAgICogKHVzdWFsbHkgdGhpbmdzIGxpa2UgcmVxdWVzdCBkdXJhdGlvbnMgYW5kIHJlc3BvbnNlIHNpemVzKS4gV2hpbGUgaXRcbiAgICogYWxzbyBwcm92aWRlcyBhIHRvdGFsIGNvdW50IG9mIG9ic2VydmF0aW9ucyBhbmQgYSBzdW0gb2YgYWxsIG9ic2VydmVkXG4gICAqIHZhbHVlcywgaXQgY2FsY3VsYXRlcyBjb25maWd1cmFibGUgcGVyY2VudGlsZXMgb3ZlciBhIHNsaWRpbmcgdGltZVxuICAgKiB3aW5kb3cuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkLCBzaW5jZSBpdCBjYW5ub3QgYmUgYWdncmVnYXRlZC5cbiAgICovXG4gIFNVTU1BUlksXG59XG5cbi8qKiBQcm9wZXJ0aWVzIG9mIGEgTGFiZWxLZXkgYXNzb2NpYXRlZCB3aXRoIGEgTWV0cmljRGVzY3JpcHRvci4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGFiZWxLZXkge1xuICAvKiogVGhlIGtleSBmb3IgdGhlIGxhYmVsLiAqL1xuICByZWFkb25seSBrZXk6IHN0cmluZztcbiAgLyoqIEEgaHVtYW4tcmVhZGFibGUgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGlzIGxhYmVsIGtleSByZXByZXNlbnRzLiAqL1xuICByZWFkb25seSBkZXNjcmlwdGlvbjogc3RyaW5nO1xufVxuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBkYXRhIHBvaW50cyB0aGF0IGRlc2NyaWJlcyB0aGUgdGltZS12YXJ5aW5nIHZhbHVlc1xuICogb2YgYSBtZXRyaWMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGltZVNlcmllcyB7XG4gIC8qKlxuICAgKiBNdXN0IGJlIHByZXNlbnQgZm9yIGN1bXVsYXRpdmUgbWV0cmljcy4gVGhlIHRpbWUgd2hlbiB0aGUgY3VtdWxhdGl2ZSB2YWx1ZVxuICAgKiB3YXMgcmVzZXQgdG8gemVyby4gRXhjbHVzaXZlLiBUaGUgY3VtdWxhdGl2ZSB2YWx1ZSBpcyBvdmVyIHRoZSB0aW1lXG4gICAqIGludGVydmFsIChzdGFydF90aW1lc3RhbXAsIHRpbWVzdGFtcF0uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBiYWNrZW5kIGNhblxuICAgKiB1c2UgdGhlIHByZXZpb3VzIHJlY29yZGVkIHZhbHVlLlxuICAgKi9cbiAgcmVhZG9ubHkgc3RhcnRUaW1lc3RhbXA/OiBUaW1lc3RhbXA7XG4gIC8qKlxuICAgKiBUaGUgc2V0IG9mIGxhYmVsIHZhbHVlcyB0aGF0IHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgdGltZXNlcmllcy4gQXBwbGllcyB0b1xuICAgKiBhbGwgcG9pbnRzLiBUaGUgb3JkZXIgb2YgbGFiZWwgdmFsdWVzIG11c3QgbWF0Y2ggdGhhdCBvZiBsYWJlbCBrZXlzIGluIHRoZVxuICAgKiBtZXRyaWMgZGVzY3JpcHRvci5cbiAgICovXG4gIHJlYWRvbmx5IGxhYmVsVmFsdWVzOiBMYWJlbFZhbHVlW107XG4gIC8qKlxuICAgKiBUaGUgZGF0YSBwb2ludHMgb2YgdGhpcyB0aW1lc2VyaWVzLiBQb2ludC52YWx1ZSB0eXBlIE1VU1QgbWF0Y2ggdGhlXG4gICAqIE1ldHJpY0Rlc2NyaXB0b3IudHlwZS5cbiAgICovXG4gIHJlYWRvbmx5IHBvaW50czogUG9pbnRbXTtcbn1cblxuLyoqIFRoZSBMYWJlbFZhbHVlIHR5cGUuIG51bGwgdmFsdWUgaW5kaWNhdGVzIGFuIHVuc2V0LiAqL1xuZXhwb3J0IGludGVyZmFjZSBMYWJlbFZhbHVlIHtcbiAgLyoqIFRoZSB2YWx1ZSBmb3IgdGhlIGxhYmVsLiAqL1xuICByZWFkb25seSB2YWx1ZTogc3RyaW5nIHwgbnVsbDtcbn1cblxuLyoqIEEgdGltZXN0YW1wZWQgbWVhc3VyZW1lbnQuICovXG5leHBvcnQgaW50ZXJmYWNlIFBvaW50IHtcbiAgLyoqXG4gICAqIFRoZSBtb21lbnQgd2hlbiB0aGlzIHBvaW50IHdhcyByZWNvcmRlZC4gSW5jbHVzaXZlLlxuICAgKiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZXN0YW1wIHdpbGwgYmUgZGVjaWRlZCBieSB0aGUgYmFja2VuZC5cbiAgICovXG4gIHJlYWRvbmx5IHRpbWVzdGFtcDogVGltZXN0YW1wO1xuICAvKipcbiAgICogVGhlIGFjdHVhbCBwb2ludCB2YWx1ZS5cbiAgICogNjQtYml0IGludGVnZXIgb3IgNjQtYml0IGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyXG4gICAqIG9yIGRpc3RyaWJ1dGlvbiB2YWx1ZVxuICAgKiBvciBzdW1tYXJ5IHZhbHVlLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZCwgc2luY2UgaXQgY2Fubm90IGJlIGFnZ3JlZ2F0ZWQuXG4gICAqL1xuICByZWFkb25seSB2YWx1ZTogbnVtYmVyIHwgRGlzdHJpYnV0aW9uVmFsdWUgfCBTdW1tYXJ5VmFsdWU7XG59XG5cbi8qKlxuICogRGlzdHJpYnV0aW9uIGNvbnRhaW5zIHN1bW1hcnkgc3RhdGlzdGljcyBmb3IgYSBwb3B1bGF0aW9uIG9mIHZhbHVlcy4gSXRcbiAqIG9wdGlvbmFsbHkgY29udGFpbnMgYSBoaXN0b2dyYW0gcmVwcmVzZW50aW5nIHRoZSBkaXN0cmlidXRpb24gb2YgdGhvc2VcbiAqIHZhbHVlcyBhY3Jvc3MgYSBzZXQgb2YgYnVja2V0cy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEaXN0cmlidXRpb25WYWx1ZSB7XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIHZhbHVlcyBpbiB0aGUgcG9wdWxhdGlvbi4gTXVzdCBiZSBub24tbmVnYXRpdmUuIFRoaXMgdmFsdWVcbiAgICogbXVzdCBlcXVhbCB0aGUgc3VtIG9mIHRoZSB2YWx1ZXMgaW4gYnVja2V0X2NvdW50cyBpZiBhIGhpc3RvZ3JhbSBpc1xuICAgKiBwcm92aWRlZC5cbiAgICovXG4gIHJlYWRvbmx5IGNvdW50OiBudW1iZXI7XG4gIC8qKlxuICAgKiBUaGUgc3VtIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHBvcHVsYXRpb24uIElmIGNvdW50IGlzIHplcm8gdGhlbiB0aGlzIGZpZWxkXG4gICAqIG11c3QgYmUgemVyby5cbiAgICovXG4gIHJlYWRvbmx5IHN1bTogbnVtYmVyO1xuICAvKipcbiAgICogVGhlIHN1bSBvZiBzcXVhcmVkIGRldmlhdGlvbnMgZnJvbSB0aGUgbWVhbiBvZiB0aGUgdmFsdWVzIGluIHRoZVxuICAgKiBwb3B1bGF0aW9uLiBGb3IgdmFsdWVzIHhfaSB0aGlzIGlzOlxuICAgKlxuICAgKiAgICAgU3VtW2k9MS4ubl0oKHhfaSAtIG1lYW4pXjIpXG4gICAqXG4gICAqIEtudXRoLCBcIlRoZSBBcnQgb2YgQ29tcHV0ZXIgUHJvZ3JhbW1pbmdcIiwgVm9sLiAyLCBwYWdlIDMyMywgM3JkIGVkaXRpb25cbiAgICogZGVzY3JpYmVzIFdlbGZvcmQncyBtZXRob2QgZm9yIGFjY3VtdWxhdGluZyB0aGlzIHN1bSBpbiBvbmUgcGFzcy5cbiAgICpcbiAgICogSWYgY291bnQgaXMgemVybyB0aGVuIHRoaXMgZmllbGQgbXVzdCBiZSB6ZXJvLlxuICAgKi9cbiAgcmVhZG9ubHkgc3VtT2ZTcXVhcmVkRGV2aWF0aW9uOiBudW1iZXI7XG4gIC8qKlxuICAgKiBEb24ndCBjaGFuZ2UgYnVja2V0IGJvdW5kYXJpZXMgd2l0aGluIGEgVGltZVNlcmllcyBpZiB5b3VyIGJhY2tlbmQgZG9lc24ndFxuICAgKiBzdXBwb3J0IHRoaXMuIFRvIHNhdmUgbmV0d29yayBiYW5kd2lkdGggdGhpcyBmaWVsZCBjYW4gYmUgc2VudCBvbmx5IHRoZVxuICAgKiBmaXJzdCB0aW1lIGEgbWV0cmljIGlzIHNlbnQgd2hlbiB1c2luZyBhIHN0cmVhbWluZyBSUEMuXG4gICAqL1xuICByZWFkb25seSBidWNrZXRPcHRpb25zOiBCdWNrZXRPcHRpb25zO1xuICAvKiogRGlzdHJpYnV0aW9uVmFsdWUgYnVja2V0cyAqL1xuICByZWFkb25seSBidWNrZXRzOiBCdWNrZXRbXTtcbn1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgQnVja2V0T3B0aW9ucy5cbiAqIEEgRGlzdHJpYnV0aW9uIG1heSBvcHRpb25hbGx5IGNvbnRhaW4gYSBoaXN0b2dyYW0gb2YgdGhlIHZhbHVlcyBpbiB0aGVcbiAqIHBvcHVsYXRpb24uIFRoZSBidWNrZXQgYm91bmRhcmllcyBmb3IgdGhhdCBoaXN0b2dyYW0gYXJlIGRlc2NyaWJlZCBieVxuICogQnVja2V0T3B0aW9ucy5cbiAqXG4gKiBJZiBidWNrZXRfb3B0aW9ucyBoYXMgbm8gdHlwZSwgdGhlbiB0aGVyZSBpcyBubyBoaXN0b2dyYW0gYXNzb2NpYXRlZCB3aXRoXG4gKiB0aGUgRGlzdHJpYnV0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJ1Y2tldE9wdGlvbnMge1xuICAvKiogQnVja2V0IHdpdGggZXhwbGljaXQgYm91bmRzLiAqL1xuICByZWFkb25seSBleHBsaWNpdDogRXhwbGljaXQ7XG59XG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhbiBFeHBsaWNpdC5cbiAqIFNwZWNpZmllcyBhIHNldCBvZiBidWNrZXRzIHdpdGggYXJiaXRyYXJ5IHVwcGVyLWJvdW5kcy5cbiAqIFRoaXMgZGVmaW5lcyBzaXplKGJvdW5kcykgKyAxICg9IE4pIGJ1Y2tldHMuIFRoZSBib3VuZGFyaWVzIGZvciBidWNrZXRcbiAqIGluZGV4IGkgYXJlOlxuICpcbiAqIFswLCBidWNrZXRfYm91bmRzW2ldKSBmb3IgaSA9PSAwXG4gKiBbYnVja2V0X2JvdW5kc1tpLTFdLCBidWNrZXRfYm91bmRzW2ldKSBmb3IgMCA8IGkgPCBOLTFcbiAqIFtidWNrZXRfYm91bmRzW2ktMV0sICtpbmZpbml0eSkgZm9yIGkgPT0gTi0xXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXhwbGljaXQge1xuICAvKiogVGhlIHZhbHVlcyBtdXN0IGJlIHN0cmljdGx5IGluY3JlYXNpbmcgYW5kID4gMC4gKi9cbiAgcmVhZG9ubHkgYm91bmRzOiBudW1iZXJbXTtcbiAgLy8gVE9ETzogSWYgT3Blbk1ldHJpY3MgZGVjaWRlcyB0byBzdXBwb3J0IChhLCBiXSBpbnRlcnZhbHMgd2Ugc2hvdWxkIGFkZFxuICAvLyBzdXBwb3J0IGZvciB0aGVzZSBieSBkZWZpbmluZyBhIGJvb2xlYW4gdmFsdWUgaGVyZSB3aGljaCBkZWNpZGVzIHdoYXRcbiAgLy8gdHlwZSBvZiBpbnRlcnZhbHMgdG8gdXNlLlxufVxuXG4vKiogUHJvcGVydGllcyBvZiBhIEJ1Y2tldC4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQnVja2V0IHtcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgdmFsdWVzIGluIGVhY2ggYnVja2V0IG9mIHRoZSBoaXN0b2dyYW0sIGFzIGRlc2NyaWJlZCBpblxuICAgKiBidWNrZXRfYm91bmRzLlxuICAgKi9cbiAgcmVhZG9ubHkgY291bnQ6IG51bWJlcjtcbiAgLyoqXG4gICAqIElmIHRoZSBkaXN0cmlidXRpb24gZG9lcyBub3QgaGF2ZSBhIGhpc3RvZ3JhbSwgdGhlbiBvbWl0IHRoaXMgZmllbGQuXG4gICAqL1xuICByZWFkb25seSBleGVtcGxhcj86IEV4ZW1wbGFyO1xufVxuXG4vKipcbiAqIEV4ZW1wbGFycyBhcmUgZXhhbXBsZSBwb2ludHMgdGhhdCBtYXkgYmUgdXNlZCB0byBhbm5vdGF0ZSBhZ2dyZWdhdGVkXG4gKiBEaXN0cmlidXRpb24gdmFsdWVzLiBUaGV5IGFyZSBtZXRhZGF0YSB0aGF0IGdpdmVzIGluZm9ybWF0aW9uIGFib3V0IGFcbiAqIHBhcnRpY3VsYXIgdmFsdWUgYWRkZWQgdG8gYSBEaXN0cmlidXRpb24gYnVja2V0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEV4ZW1wbGFyIHtcbiAgLyoqXG4gICAqIFZhbHVlIG9mIHRoZSBleGVtcGxhciBwb2ludC4gSXQgZGV0ZXJtaW5lcyB3aGljaCBidWNrZXQgdGhlIGV4ZW1wbGFyXG4gICAqIGJlbG9uZ3MgdG8uXG4gICAqL1xuICByZWFkb25seSB2YWx1ZTogbnVtYmVyO1xuICAvKiogVGhlIG9ic2VydmF0aW9uIChzYW1wbGluZykgdGltZSBvZiB0aGUgYWJvdmUgdmFsdWUuICovXG4gIHJlYWRvbmx5IHRpbWVzdGFtcDogVGltZXN0YW1wO1xuICAvKiogQ29udGV4dHVhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXhhbXBsZSB2YWx1ZS4gKi9cbiAgcmVhZG9ubHkgYXR0YWNobWVudHM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG59XG5cbi8qKlxuICogVGhlIHN0YXJ0X3RpbWVzdGFtcCBvbmx5IGFwcGxpZXMgdG8gdGhlIGNvdW50IGFuZCBzdW0gaW4gdGhlIFN1bW1hcnlWYWx1ZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdW1tYXJ5VmFsdWUge1xuICAvKipcbiAgICogVGhlIHRvdGFsIG51bWJlciBvZiByZWNvcmRlZCB2YWx1ZXMgc2luY2Ugc3RhcnRfdGltZS4gT3B0aW9uYWwgc2luY2VcbiAgICogc29tZSBzeXN0ZW1zIGRvbid0IGV4cG9zZSB0aGlzLlxuICAgKi9cbiAgcmVhZG9ubHkgY291bnQ6IG51bWJlcjtcbiAgLyoqXG4gICAqIFRoZSB0b3RhbCBzdW0gb2YgcmVjb3JkZWQgdmFsdWVzIHNpbmNlIHN0YXJ0X3RpbWUuIE9wdGlvbmFsIHNpbmNlIHNvbWVcbiAgICogc3lzdGVtcyBkb24ndCBleHBvc2UgdGhpcy4gSWYgY291bnQgaXMgemVybyB0aGVuIHRoaXMgZmllbGQgbXVzdCBiZSB6ZXJvLlxuICAgKiBUaGlzIGZpZWxkIG11c3QgYmUgdW5zZXQgaWYgdGhlIHN1bSBpcyBub3QgYXZhaWxhYmxlLlxuICAgKi9cbiAgcmVhZG9ubHkgc3VtOiBudW1iZXI7XG4gIC8qKiBWYWx1ZXMgY2FsY3VsYXRlZCBvdmVyIGFuIGFyYml0cmFyeSB0aW1lIHdpbmRvdy4gKi9cbiAgLy8gVE9ETzogQ2hhbmdlIGl0IHRvIHJlcXVpcmVkIHdoZW4gRXhlbXBsYXIgZnVuY3Rpb25hbGl0eSB3aWxsIGJlIGFkZGVkLlxuICByZWFkb25seSBzbmFwc2hvdD86IFNuYXBzaG90O1xufVxuXG4vKipcbiAqIFRoZSB2YWx1ZXMgaW4gdGhpcyBtZXNzYWdlIGNhbiBiZSByZXNldCBhdCBhcmJpdHJhcnkgdW5rbm93biB0aW1lcywgd2l0aFxuICogdGhlIHJlcXVpcmVtZW50IHRoYXQgYWxsIG9mIHRoZW0gYXJlIHJlc2V0IGF0IHRoZSBzYW1lIHRpbWUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU25hcHNob3Qge1xuICAvKipcbiAgICogVGhlIG51bWJlciBvZiB2YWx1ZXMgaW4gdGhlIHNuYXBzaG90LiBPcHRpb25hbCBzaW5jZSBzb21lIHN5c3RlbXMgZG9uJ3RcbiAgICogZXhwb3NlIHRoaXMuXG4gICAqL1xuICByZWFkb25seSBjb3VudDogbnVtYmVyO1xuICAvKipcbiAgICogVGhlIHN1bSBvZiB2YWx1ZXMgaW4gdGhlIHNuYXBzaG90LiBPcHRpb25hbCBzaW5jZSBzb21lIHN5c3RlbXMgZG9uJ3RcbiAgICogZXhwb3NlIHRoaXMuIElmIGNvdW50IGlzIHplcm8gdGhlbiB0aGlzIGZpZWxkIG11c3QgYmUgemVybyBvciBub3Qgc2V0XG4gICAqIChpZiBub3Qgc3VwcG9ydGVkKS5cbiAgICovXG4gIHJlYWRvbmx5IHN1bTogbnVtYmVyO1xuICAvKipcbiAgICogQSBsaXN0IG9mIHZhbHVlcyBhdCBkaWZmZXJlbnQgcGVyY2VudGlsZXMgb2YgdGhlIGRpc3RyaWJ1dGlvbiBjYWxjdWxhdGVkXG4gICAqIGZyb20gdGhlIGN1cnJlbnQgc25hcHNob3QuIFRoZSBwZXJjZW50aWxlcyBtdXN0IGJlIHN0cmljdGx5IGluY3JlYXNpbmcuXG4gICAqL1xuICByZWFkb25seSBwZXJjZW50aWxlVmFsdWVzOiBWYWx1ZUF0UGVyY2VudGlsZVtdO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHZhbHVlIGF0IGEgZ2l2ZW4gcGVyY2VudGlsZSBvZiBhIGRpc3RyaWJ1dGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWYWx1ZUF0UGVyY2VudGlsZSB7XG4gIC8qKiBUaGUgcGVyY2VudGlsZSBvZiBhIGRpc3RyaWJ1dGlvbi4gTXVzdCBiZSBpbiB0aGUgaW50ZXJ2YWwgKDAuMCwgMTAwLjBdLiAqL1xuICByZWFkb25seSBwZXJjZW50aWxlOiBudW1iZXI7XG4gIC8qKiBUaGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBlcmNlbnRpbGUgb2YgYSBkaXN0cmlidXRpb24uICovXG4gIHJlYWRvbmx5IHZhbHVlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGltZXN0YW1wIHtcbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgc2Vjb25kcyBvZiBVVEMgdGltZSBzaW5jZSBVbml4IGVwb2NoXG4gICAqIDE5NzAtMDEtMDFUMDA6MDA6MDBaLiBNdXN0IGJlIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG9cbiAgICogOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlLlxuICAgKi9cbiAgc2Vjb25kczogbnVtYmVyIHwgbnVsbDtcbiAgLyoqXG4gICAqIE5vbi1uZWdhdGl2ZSBmcmFjdGlvbnMgb2YgYSBzZWNvbmQgYXQgbmFub3NlY29uZCByZXNvbHV0aW9uLiBOZWdhdGl2ZVxuICAgKiBzZWNvbmQgdmFsdWVzIHdpdGggZnJhY3Rpb25zIG11c3Qgc3RpbGwgaGF2ZSBub24tbmVnYXRpdmUgbmFub3MgdmFsdWVzXG4gICAqIHRoYXQgY291bnQgZm9yd2FyZCBpbiB0aW1lLiBNdXN0IGJlIGZyb20gMCB0byA5OTksOTk5LDk5OVxuICAgKiBpbmNsdXNpdmUuXG4gICAqL1xuICBuYW5vczogbnVtYmVyIHwgbnVsbDtcbn1cblxuLyoqXG4gKiBLZWVwcyBhIHNldCBvZiBNZXRyaWNQcm9kdWNlciB0aGF0IGlzIHVzZWQgYnkgZXhwb3J0ZXJzIHRvIGRldGVybWluZSB0aGVcbiAqIG1ldHJpY3MgdGhhdCBuZWVkIHRvIGJlIGV4cG9ydGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1ldHJpY1Byb2R1Y2VyTWFuYWdlciB7XG4gIC8qKiBBZGRzIHRoZSBNZXRyaWNQcm9kdWNlciB0byB0aGUgbWFuYWdlciAqL1xuICBhZGQobWV0cmljUHJvZHVjZXI6IE1ldHJpY1Byb2R1Y2VyKTogdm9pZDtcbiAgLyoqIFJlbW92ZXMgdGhlIE1ldHJpY1Byb2R1Y2VyIHRvIHRoZSBtYW5hZ2VyICovXG4gIHJlbW92ZShtZXRyaWNQcm9kdWNlcjogTWV0cmljUHJvZHVjZXIpOiB2b2lkO1xuICAvKiogQ2xlYXJzIGFsbCBNZXRyaWNQcm9kdWNlcnMgKi9cbiAgcmVtb3ZlQWxsKCk6IHZvaWQ7XG4gIC8qKiBHZXRzIGFsbCByZWdpc3RlcmVkIE1ldHJpY1Byb2R1Y2VycyB0aGF0IHNob3VsZCBiZSBleHBvcnRlZCAqL1xuICBnZXRBbGxNZXRyaWNQcm9kdWNlcigpOiBTZXQ8TWV0cmljUHJvZHVjZXI+O1xufVxuXG4vKipcbiAqIEEgTWV0cmljUHJvZHVjZXIgcHJvZHVjZXIgdGhhdCBjYW4gYmUgcmVnaXN0ZXJlZCBmb3IgZXhwb3J0aW5nIHVzaW5nXG4gKiBNZXRyaWNQcm9kdWNlck1hbmFnZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWV0cmljUHJvZHVjZXIge1xuICAvKiogR2V0cyBhIGNvbGxlY3Rpb24gb2YgcHJvZHVjZWQgTWV0cmljYHMgdG8gYmUgZXhwb3J0ZWQgKi9cbiAgZ2V0TWV0cmljcygpOiBNZXRyaWNbXTtcbn1cbiJdfQ==
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjb3ZfMmRpZWtmOTc0dCIsInBhdGgiLCJoYXNoIiwiZ2xvYmFsIiwiRnVuY3Rpb24iLCJnY3YiLCJjb3ZlcmFnZURhdGEiLCJzdGF0ZW1lbnRNYXAiLCJzdGFydCIsImxpbmUiLCJjb2x1bW4iLCJlbmQiLCJmbk1hcCIsIm5hbWUiLCJkZWNsIiwibG9jIiwiYnJhbmNoTWFwIiwidHlwZSIsImxvY2F0aW9ucyIsInMiLCJmIiwiYiIsImlucHV0U291cmNlTWFwIiwidmVyc2lvbiIsImZpbGUiLCJzb3VyY2VzIiwibmFtZXMiLCJtYXBwaW5ncyIsInNvdXJjZXNDb250ZW50IiwiX2NvdmVyYWdlU2NoZW1hIiwiY292ZXJhZ2UiLCJhY3R1YWxDb3ZlcmFnZSIsIk1ldHJpY0Rlc2NyaXB0b3JUeXBlIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbIi9Vc2Vycy91c2VybWFpdGhhL3RyYWRlbWFzdGVyL2xpYnMvbGliLWV4dGVybmFsLW9wZW5jZW5zdXMtbm9kZS9zcmMvbWV0cmljcy9leHBvcnQvdHlwZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAxOCwgT3BlbkNlbnN1cyBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogUHJvcGVydGllcyBvZiBhIE1ldHJpYyB3aGljaCBoYXMgb25lIG9yIG1vcmUgdGltZXNlcmllcyAqL1xuZXhwb3J0IGludGVyZmFjZSBNZXRyaWMge1xuICAvKipcbiAgICogVGhlIGRlc2NyaXB0b3Igb2YgdGhlIE1ldHJpYy4gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gZm9yIG5ldHdvcmsgd2lyZVxuICAgKiBzaXplLCBmcm9tIGRhdGEtbW9kZWwgcGVyc3BlY3RpdmUgYSBNZXRyaWMgY29udGFpbnMgYWx3YXlzXG4gICAqIGEgTWV0cmljRGVzY3JpcHRvci5cbiAgICogSW4gY2FzZSBvZiBhIHN0cmVhbWluZyBSUEMgY2FuIGJlIHNlbnQgb25seVxuICAgKiB0aGUgZmlyc3QgdGltZSBhIG1ldHJpYyBpcyByZXBvcnRlZCB0byBzYXZlIG5ldHdvcmsgdHJhZmZpYy5cbiAgICovXG4gIHJlYWRvbmx5IGRlc2NyaXB0b3I6IE1ldHJpY0Rlc2NyaXB0b3I7XG4gIC8qKlxuICAgKiBPbmUgb3IgbW9yZSB0aW1lc2VyaWVzIGZvciBhIHNpbmdsZSBtZXRyaWMsIHdoZXJlIGVhY2ggdGltZXNlcmllcyBoYXNcbiAgICogb25lIG9yIG1vcmUgcG9pbnRzLlxuICAgKi9cbiAgcmVhZG9ubHkgdGltZXNlcmllczogVGltZVNlcmllc1tdO1xufVxuXG4vKiogUHJvcGVydGllcyBvZiBhIE1ldHJpYyB0eXBlIGFuZCBpdHMgc2NoZW1hICovXG5leHBvcnQgaW50ZXJmYWNlIE1ldHJpY0Rlc2NyaXB0b3Ige1xuICAvKiogIFRoZSBtZXRyaWMgdHlwZSwgaW5jbHVkaW5nIGl0cyBETlMgbmFtZSBwcmVmaXguIEl0IG11c3QgYmUgdW5pcXVlLiAqL1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBIGRldGFpbGVkIGRlc2NyaXB0aW9uIG9mIHRoZSBtZXRyaWMsIHdoaWNoIGNhbiBiZSB1c2VkIGluIGRvY3VtZW50YXRpb24uXG4gICAqL1xuICByZWFkb25seSBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHVuaXQgaW4gd2hpY2ggdGhlIG1ldHJpYyB2YWx1ZSBpcyByZXBvcnRlZC4gRm9sbG93cyB0aGUgZm9ybWF0XG4gICAqIGRlc2NyaWJlZCBieSBodHRwOi8vdW5pdHNvZm1lYXN1cmUub3JnL3VjdW0uaHRtbC5cbiAgICovXG4gIHJlYWRvbmx5IHVuaXQ6IHN0cmluZztcbiAgLyoqIE1ldHJpY0Rlc2NyaXB0b3IgdHlwZSAqL1xuICByZWFkb25seSB0eXBlOiBNZXRyaWNEZXNjcmlwdG9yVHlwZTtcbiAgLyoqIFRoZSBsYWJlbCBrZXlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWV0cmljIGRlc2NyaXB0b3IuICovXG4gIHJlYWRvbmx5IGxhYmVsS2V5czogTGFiZWxLZXlbXTtcbn1cblxuLyoqXG4gKiBUaGUga2luZCBvZiBtZXRyaWMuIEl0IGRlc2NyaWJlcyBob3cgdGhlIGRhdGEgaXMgcmVwb3J0ZWQuXG4gKlxuICogQSBnYXVnZSBpcyBhbiBpbnN0YW50YW5lb3VzIG1lYXN1cmVtZW50IG9mIGEgdmFsdWUuXG4gKlxuICogQSBjdW11bGF0aXZlIG1lYXN1cmVtZW50IGlzIGEgdmFsdWUgYWNjdW11bGF0ZWQgb3ZlciBhIHRpbWUgaW50ZXJ2YWwuIEluXG4gKiBhIHRpbWUgc2VyaWVzLCBjdW11bGF0aXZlIG1lYXN1cmVtZW50cyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBzdGFydCB0aW1lLFxuICogaW5jcmVhc2luZyB2YWx1ZXMgYW5kIGluY3JlYXNpbmcgZW5kIHRpbWVzLCB1bnRpbCBhbiBldmVudCByZXNldHMgdGhlXG4gKiBjdW11bGF0aXZlIHZhbHVlIHRvIHplcm8gYW5kIHNldHMgYSBuZXcgc3RhcnQgdGltZSBmb3IgdGhlIGZvbGxvd2luZ1xuICogcG9pbnRzLlxuICovXG5leHBvcnQgZW51bSBNZXRyaWNEZXNjcmlwdG9yVHlwZSB7XG4gIC8qKiBEbyBub3QgdXNlIHRoaXMgZGVmYXVsdCB2YWx1ZS4gKi9cbiAgVU5TUEVDSUZJRUQsXG4gIC8qKiBJbnRlZ2VyIGdhdWdlLiBUaGUgdmFsdWUgY2FuIGdvIGJvdGggdXAgYW5kIGRvd24uICovXG4gIEdBVUdFX0lOVDY0LFxuICAvKiogRmxvYXRpbmcgcG9pbnQgZ2F1Z2UuIFRoZSB2YWx1ZSBjYW4gZ28gYm90aCB1cCBhbmQgZG93bi4gKi9cbiAgR0FVR0VfRE9VQkxFLFxuICAvKipcbiAgICogRGlzdHJpYnV0aW9uIGdhdWdlIG1lYXN1cmVtZW50LiBUaGUgY291bnQgYW5kIHN1bSBjYW4gZ28gYm90aCB1cCBhbmRcbiAgICogZG93bi4gUmVjb3JkZWQgdmFsdWVzIGFyZSBhbHdheXMgPj0gMC5cbiAgICogVXNlZCBpbiBzY2VuYXJpb3MgbGlrZSBhIHNuYXBzaG90IG9mIHRpbWUgdGhlIGN1cnJlbnQgaXRlbXMgaW4gYSBxdWV1ZVxuICAgKiBoYXZlIHNwZW50IHRoZXJlLlxuICAgKi9cbiAgR0FVR0VfRElTVFJJQlVUSU9OLFxuICAvKipcbiAgICogSW50ZWdlciBjdW11bGF0aXZlIG1lYXN1cmVtZW50LiBUaGUgdmFsdWUgY2Fubm90IGRlY3JlYXNlLCBpZiByZXNldHNcbiAgICogdGhlbiB0aGUgc3RhcnRfdGltZSBzaG91bGQgYWxzbyBiZSByZXNldC5cbiAgICovXG4gIENVTVVMQVRJVkVfSU5UNjQsXG4gIC8qKlxuICAgKiBGbG9hdGluZyBwb2ludCBjdW11bGF0aXZlIG1lYXN1cmVtZW50LiBUaGUgdmFsdWUgY2Fubm90IGRlY3JlYXNlLCBpZlxuICAgKiByZXNldHMgdGhlbiB0aGUgc3RhcnRfdGltZSBzaG91bGQgYWxzbyBiZSByZXNldC4gUmVjb3JkZWQgdmFsdWVzIGFyZVxuICAgKiBhbHdheXMgPj0gMC5cbiAgICovXG4gIENVTVVMQVRJVkVfRE9VQkxFLFxuICAvKipcbiAgICogRGlzdHJpYnV0aW9uIGN1bXVsYXRpdmUgbWVhc3VyZW1lbnQuIFRoZSBjb3VudCBhbmQgc3VtIGNhbm5vdCBkZWNyZWFzZSxcbiAgICogaWYgcmVzZXRzIHRoZW4gdGhlIHN0YXJ0X3RpbWUgc2hvdWxkIGFsc28gYmUgcmVzZXQuXG4gICAqL1xuICBDVU1VTEFUSVZFX0RJU1RSSUJVVElPTixcbiAgLyoqXG4gICAqIFNvbWUgZnJhbWV3b3JrcyBpbXBsZW1lbnRlZCBIaXN0b2dyYW1zIGFzIGEgc3VtbWFyeSBvZiBvYnNlcnZhdGlvbnNcbiAgICogKHVzdWFsbHkgdGhpbmdzIGxpa2UgcmVxdWVzdCBkdXJhdGlvbnMgYW5kIHJlc3BvbnNlIHNpemVzKS4gV2hpbGUgaXRcbiAgICogYWxzbyBwcm92aWRlcyBhIHRvdGFsIGNvdW50IG9mIG9ic2VydmF0aW9ucyBhbmQgYSBzdW0gb2YgYWxsIG9ic2VydmVkXG4gICAqIHZhbHVlcywgaXQgY2FsY3VsYXRlcyBjb25maWd1cmFibGUgcGVyY2VudGlsZXMgb3ZlciBhIHNsaWRpbmcgdGltZVxuICAgKiB3aW5kb3cuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkLCBzaW5jZSBpdCBjYW5ub3QgYmUgYWdncmVnYXRlZC5cbiAgICovXG4gIFNVTU1BUlksXG59XG5cbi8qKiBQcm9wZXJ0aWVzIG9mIGEgTGFiZWxLZXkgYXNzb2NpYXRlZCB3aXRoIGEgTWV0cmljRGVzY3JpcHRvci4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGFiZWxLZXkge1xuICAvKiogVGhlIGtleSBmb3IgdGhlIGxhYmVsLiAqL1xuICByZWFkb25seSBrZXk6IHN0cmluZztcbiAgLyoqIEEgaHVtYW4tcmVhZGFibGUgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGlzIGxhYmVsIGtleSByZXByZXNlbnRzLiAqL1xuICByZWFkb25seSBkZXNjcmlwdGlvbjogc3RyaW5nO1xufVxuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBkYXRhIHBvaW50cyB0aGF0IGRlc2NyaWJlcyB0aGUgdGltZS12YXJ5aW5nIHZhbHVlc1xuICogb2YgYSBtZXRyaWMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGltZVNlcmllcyB7XG4gIC8qKlxuICAgKiBNdXN0IGJlIHByZXNlbnQgZm9yIGN1bXVsYXRpdmUgbWV0cmljcy4gVGhlIHRpbWUgd2hlbiB0aGUgY3VtdWxhdGl2ZSB2YWx1ZVxuICAgKiB3YXMgcmVzZXQgdG8gemVyby4gRXhjbHVzaXZlLiBUaGUgY3VtdWxhdGl2ZSB2YWx1ZSBpcyBvdmVyIHRoZSB0aW1lXG4gICAqIGludGVydmFsIChzdGFydF90aW1lc3RhbXAsIHRpbWVzdGFtcF0uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBiYWNrZW5kIGNhblxuICAgKiB1c2UgdGhlIHByZXZpb3VzIHJlY29yZGVkIHZhbHVlLlxuICAgKi9cbiAgcmVhZG9ubHkgc3RhcnRUaW1lc3RhbXA/OiBUaW1lc3RhbXA7XG4gIC8qKlxuICAgKiBUaGUgc2V0IG9mIGxhYmVsIHZhbHVlcyB0aGF0IHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgdGltZXNlcmllcy4gQXBwbGllcyB0b1xuICAgKiBhbGwgcG9pbnRzLiBUaGUgb3JkZXIgb2YgbGFiZWwgdmFsdWVzIG11c3QgbWF0Y2ggdGhhdCBvZiBsYWJlbCBrZXlzIGluIHRoZVxuICAgKiBtZXRyaWMgZGVzY3JpcHRvci5cbiAgICovXG4gIHJlYWRvbmx5IGxhYmVsVmFsdWVzOiBMYWJlbFZhbHVlW107XG4gIC8qKlxuICAgKiBUaGUgZGF0YSBwb2ludHMgb2YgdGhpcyB0aW1lc2VyaWVzLiBQb2ludC52YWx1ZSB0eXBlIE1VU1QgbWF0Y2ggdGhlXG4gICAqIE1ldHJpY0Rlc2NyaXB0b3IudHlwZS5cbiAgICovXG4gIHJlYWRvbmx5IHBvaW50czogUG9pbnRbXTtcbn1cblxuLyoqIFRoZSBMYWJlbFZhbHVlIHR5cGUuIG51bGwgdmFsdWUgaW5kaWNhdGVzIGFuIHVuc2V0LiAqL1xuZXhwb3J0IGludGVyZmFjZSBMYWJlbFZhbHVlIHtcbiAgLyoqIFRoZSB2YWx1ZSBmb3IgdGhlIGxhYmVsLiAqL1xuICByZWFkb25seSB2YWx1ZTogc3RyaW5nIHwgbnVsbDtcbn1cblxuLyoqIEEgdGltZXN0YW1wZWQgbWVhc3VyZW1lbnQuICovXG5leHBvcnQgaW50ZXJmYWNlIFBvaW50IHtcbiAgLyoqXG4gICAqIFRoZSBtb21lbnQgd2hlbiB0aGlzIHBvaW50IHdhcyByZWNvcmRlZC4gSW5jbHVzaXZlLlxuICAgKiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZXN0YW1wIHdpbGwgYmUgZGVjaWRlZCBieSB0aGUgYmFja2VuZC5cbiAgICovXG4gIHJlYWRvbmx5IHRpbWVzdGFtcDogVGltZXN0YW1wO1xuICAvKipcbiAgICogVGhlIGFjdHVhbCBwb2ludCB2YWx1ZS5cbiAgICogNjQtYml0IGludGVnZXIgb3IgNjQtYml0IGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyXG4gICAqIG9yIGRpc3RyaWJ1dGlvbiB2YWx1ZVxuICAgKiBvciBzdW1tYXJ5IHZhbHVlLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZCwgc2luY2UgaXQgY2Fubm90IGJlIGFnZ3JlZ2F0ZWQuXG4gICAqL1xuICByZWFkb25seSB2YWx1ZTogbnVtYmVyIHwgRGlzdHJpYnV0aW9uVmFsdWUgfCBTdW1tYXJ5VmFsdWU7XG59XG5cbi8qKlxuICogRGlzdHJpYnV0aW9uIGNvbnRhaW5zIHN1bW1hcnkgc3RhdGlzdGljcyBmb3IgYSBwb3B1bGF0aW9uIG9mIHZhbHVlcy4gSXRcbiAqIG9wdGlvbmFsbHkgY29udGFpbnMgYSBoaXN0b2dyYW0gcmVwcmVzZW50aW5nIHRoZSBkaXN0cmlidXRpb24gb2YgdGhvc2VcbiAqIHZhbHVlcyBhY3Jvc3MgYSBzZXQgb2YgYnVja2V0cy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEaXN0cmlidXRpb25WYWx1ZSB7XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIHZhbHVlcyBpbiB0aGUgcG9wdWxhdGlvbi4gTXVzdCBiZSBub24tbmVnYXRpdmUuIFRoaXMgdmFsdWVcbiAgICogbXVzdCBlcXVhbCB0aGUgc3VtIG9mIHRoZSB2YWx1ZXMgaW4gYnVja2V0X2NvdW50cyBpZiBhIGhpc3RvZ3JhbSBpc1xuICAgKiBwcm92aWRlZC5cbiAgICovXG4gIHJlYWRvbmx5IGNvdW50OiBudW1iZXI7XG4gIC8qKlxuICAgKiBUaGUgc3VtIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHBvcHVsYXRpb24uIElmIGNvdW50IGlzIHplcm8gdGhlbiB0aGlzIGZpZWxkXG4gICAqIG11c3QgYmUgemVyby5cbiAgICovXG4gIHJlYWRvbmx5IHN1bTogbnVtYmVyO1xuICAvKipcbiAgICogVGhlIHN1bSBvZiBzcXVhcmVkIGRldmlhdGlvbnMgZnJvbSB0aGUgbWVhbiBvZiB0aGUgdmFsdWVzIGluIHRoZVxuICAgKiBwb3B1bGF0aW9uLiBGb3IgdmFsdWVzIHhfaSB0aGlzIGlzOlxuICAgKlxuICAgKiAgICAgU3VtW2k9MS4ubl0oKHhfaSAtIG1lYW4pXjIpXG4gICAqXG4gICAqIEtudXRoLCBcIlRoZSBBcnQgb2YgQ29tcHV0ZXIgUHJvZ3JhbW1pbmdcIiwgVm9sLiAyLCBwYWdlIDMyMywgM3JkIGVkaXRpb25cbiAgICogZGVzY3JpYmVzIFdlbGZvcmQncyBtZXRob2QgZm9yIGFjY3VtdWxhdGluZyB0aGlzIHN1bSBpbiBvbmUgcGFzcy5cbiAgICpcbiAgICogSWYgY291bnQgaXMgemVybyB0aGVuIHRoaXMgZmllbGQgbXVzdCBiZSB6ZXJvLlxuICAgKi9cbiAgcmVhZG9ubHkgc3VtT2ZTcXVhcmVkRGV2aWF0aW9uOiBudW1iZXI7XG4gIC8qKlxuICAgKiBEb24ndCBjaGFuZ2UgYnVja2V0IGJvdW5kYXJpZXMgd2l0aGluIGEgVGltZVNlcmllcyBpZiB5b3VyIGJhY2tlbmQgZG9lc24ndFxuICAgKiBzdXBwb3J0IHRoaXMuIFRvIHNhdmUgbmV0d29yayBiYW5kd2lkdGggdGhpcyBmaWVsZCBjYW4gYmUgc2VudCBvbmx5IHRoZVxuICAgKiBmaXJzdCB0aW1lIGEgbWV0cmljIGlzIHNlbnQgd2hlbiB1c2luZyBhIHN0cmVhbWluZyBSUEMuXG4gICAqL1xuICByZWFkb25seSBidWNrZXRPcHRpb25zOiBCdWNrZXRPcHRpb25zO1xuICAvKiogRGlzdHJpYnV0aW9uVmFsdWUgYnVja2V0cyAqL1xuICByZWFkb25seSBidWNrZXRzOiBCdWNrZXRbXTtcbn1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgQnVja2V0T3B0aW9ucy5cbiAqIEEgRGlzdHJpYnV0aW9uIG1heSBvcHRpb25hbGx5IGNvbnRhaW4gYSBoaXN0b2dyYW0gb2YgdGhlIHZhbHVlcyBpbiB0aGVcbiAqIHBvcHVsYXRpb24uIFRoZSBidWNrZXQgYm91bmRhcmllcyBmb3IgdGhhdCBoaXN0b2dyYW0gYXJlIGRlc2NyaWJlZCBieVxuICogQnVja2V0T3B0aW9ucy5cbiAqXG4gKiBJZiBidWNrZXRfb3B0aW9ucyBoYXMgbm8gdHlwZSwgdGhlbiB0aGVyZSBpcyBubyBoaXN0b2dyYW0gYXNzb2NpYXRlZCB3aXRoXG4gKiB0aGUgRGlzdHJpYnV0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJ1Y2tldE9wdGlvbnMge1xuICAvKiogQnVja2V0IHdpdGggZXhwbGljaXQgYm91bmRzLiAqL1xuICByZWFkb25seSBleHBsaWNpdDogRXhwbGljaXQ7XG59XG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhbiBFeHBsaWNpdC5cbiAqIFNwZWNpZmllcyBhIHNldCBvZiBidWNrZXRzIHdpdGggYXJiaXRyYXJ5IHVwcGVyLWJvdW5kcy5cbiAqIFRoaXMgZGVmaW5lcyBzaXplKGJvdW5kcykgKyAxICg9IE4pIGJ1Y2tldHMuIFRoZSBib3VuZGFyaWVzIGZvciBidWNrZXRcbiAqIGluZGV4IGkgYXJlOlxuICpcbiAqIFswLCBidWNrZXRfYm91bmRzW2ldKSBmb3IgaSA9PSAwXG4gKiBbYnVja2V0X2JvdW5kc1tpLTFdLCBidWNrZXRfYm91bmRzW2ldKSBmb3IgMCA8IGkgPCBOLTFcbiAqIFtidWNrZXRfYm91bmRzW2ktMV0sICtpbmZpbml0eSkgZm9yIGkgPT0gTi0xXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXhwbGljaXQge1xuICAvKiogVGhlIHZhbHVlcyBtdXN0IGJlIHN0cmljdGx5IGluY3JlYXNpbmcgYW5kID4gMC4gKi9cbiAgcmVhZG9ubHkgYm91bmRzOiBudW1iZXJbXTtcbiAgLy8gVE9ETzogSWYgT3Blbk1ldHJpY3MgZGVjaWRlcyB0byBzdXBwb3J0IChhLCBiXSBpbnRlcnZhbHMgd2Ugc2hvdWxkIGFkZFxuICAvLyBzdXBwb3J0IGZvciB0aGVzZSBieSBkZWZpbmluZyBhIGJvb2xlYW4gdmFsdWUgaGVyZSB3aGljaCBkZWNpZGVzIHdoYXRcbiAgLy8gdHlwZSBvZiBpbnRlcnZhbHMgdG8gdXNlLlxufVxuXG4vKiogUHJvcGVydGllcyBvZiBhIEJ1Y2tldC4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQnVja2V0IHtcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgdmFsdWVzIGluIGVhY2ggYnVja2V0IG9mIHRoZSBoaXN0b2dyYW0sIGFzIGRlc2NyaWJlZCBpblxuICAgKiBidWNrZXRfYm91bmRzLlxuICAgKi9cbiAgcmVhZG9ubHkgY291bnQ6IG51bWJlcjtcbiAgLyoqXG4gICAqIElmIHRoZSBkaXN0cmlidXRpb24gZG9lcyBub3QgaGF2ZSBhIGhpc3RvZ3JhbSwgdGhlbiBvbWl0IHRoaXMgZmllbGQuXG4gICAqL1xuICByZWFkb25seSBleGVtcGxhcj86IEV4ZW1wbGFyO1xufVxuXG4vKipcbiAqIEV4ZW1wbGFycyBhcmUgZXhhbXBsZSBwb2ludHMgdGhhdCBtYXkgYmUgdXNlZCB0byBhbm5vdGF0ZSBhZ2dyZWdhdGVkXG4gKiBEaXN0cmlidXRpb24gdmFsdWVzLiBUaGV5IGFyZSBtZXRhZGF0YSB0aGF0IGdpdmVzIGluZm9ybWF0aW9uIGFib3V0IGFcbiAqIHBhcnRpY3VsYXIgdmFsdWUgYWRkZWQgdG8gYSBEaXN0cmlidXRpb24gYnVja2V0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEV4ZW1wbGFyIHtcbiAgLyoqXG4gICAqIFZhbHVlIG9mIHRoZSBleGVtcGxhciBwb2ludC4gSXQgZGV0ZXJtaW5lcyB3aGljaCBidWNrZXQgdGhlIGV4ZW1wbGFyXG4gICAqIGJlbG9uZ3MgdG8uXG4gICAqL1xuICByZWFkb25seSB2YWx1ZTogbnVtYmVyO1xuICAvKiogVGhlIG9ic2VydmF0aW9uIChzYW1wbGluZykgdGltZSBvZiB0aGUgYWJvdmUgdmFsdWUuICovXG4gIHJlYWRvbmx5IHRpbWVzdGFtcDogVGltZXN0YW1wO1xuICAvKiogQ29udGV4dHVhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXhhbXBsZSB2YWx1ZS4gKi9cbiAgcmVhZG9ubHkgYXR0YWNobWVudHM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG59XG5cbi8qKlxuICogVGhlIHN0YXJ0X3RpbWVzdGFtcCBvbmx5IGFwcGxpZXMgdG8gdGhlIGNvdW50IGFuZCBzdW0gaW4gdGhlIFN1bW1hcnlWYWx1ZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdW1tYXJ5VmFsdWUge1xuICAvKipcbiAgICogVGhlIHRvdGFsIG51bWJlciBvZiByZWNvcmRlZCB2YWx1ZXMgc2luY2Ugc3RhcnRfdGltZS4gT3B0aW9uYWwgc2luY2VcbiAgICogc29tZSBzeXN0ZW1zIGRvbid0IGV4cG9zZSB0aGlzLlxuICAgKi9cbiAgcmVhZG9ubHkgY291bnQ6IG51bWJlcjtcbiAgLyoqXG4gICAqIFRoZSB0b3RhbCBzdW0gb2YgcmVjb3JkZWQgdmFsdWVzIHNpbmNlIHN0YXJ0X3RpbWUuIE9wdGlvbmFsIHNpbmNlIHNvbWVcbiAgICogc3lzdGVtcyBkb24ndCBleHBvc2UgdGhpcy4gSWYgY291bnQgaXMgemVybyB0aGVuIHRoaXMgZmllbGQgbXVzdCBiZSB6ZXJvLlxuICAgKiBUaGlzIGZpZWxkIG11c3QgYmUgdW5zZXQgaWYgdGhlIHN1bSBpcyBub3QgYXZhaWxhYmxlLlxuICAgKi9cbiAgcmVhZG9ubHkgc3VtOiBudW1iZXI7XG4gIC8qKiBWYWx1ZXMgY2FsY3VsYXRlZCBvdmVyIGFuIGFyYml0cmFyeSB0aW1lIHdpbmRvdy4gKi9cbiAgLy8gVE9ETzogQ2hhbmdlIGl0IHRvIHJlcXVpcmVkIHdoZW4gRXhlbXBsYXIgZnVuY3Rpb25hbGl0eSB3aWxsIGJlIGFkZGVkLlxuICByZWFkb25seSBzbmFwc2hvdD86IFNuYXBzaG90O1xufVxuXG4vKipcbiAqIFRoZSB2YWx1ZXMgaW4gdGhpcyBtZXNzYWdlIGNhbiBiZSByZXNldCBhdCBhcmJpdHJhcnkgdW5rbm93biB0aW1lcywgd2l0aFxuICogdGhlIHJlcXVpcmVtZW50IHRoYXQgYWxsIG9mIHRoZW0gYXJlIHJlc2V0IGF0IHRoZSBzYW1lIHRpbWUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU25hcHNob3Qge1xuICAvKipcbiAgICogVGhlIG51bWJlciBvZiB2YWx1ZXMgaW4gdGhlIHNuYXBzaG90LiBPcHRpb25hbCBzaW5jZSBzb21lIHN5c3RlbXMgZG9uJ3RcbiAgICogZXhwb3NlIHRoaXMuXG4gICAqL1xuICByZWFkb25seSBjb3VudDogbnVtYmVyO1xuICAvKipcbiAgICogVGhlIHN1bSBvZiB2YWx1ZXMgaW4gdGhlIHNuYXBzaG90LiBPcHRpb25hbCBzaW5jZSBzb21lIHN5c3RlbXMgZG9uJ3RcbiAgICogZXhwb3NlIHRoaXMuIElmIGNvdW50IGlzIHplcm8gdGhlbiB0aGlzIGZpZWxkIG11c3QgYmUgemVybyBvciBub3Qgc2V0XG4gICAqIChpZiBub3Qgc3VwcG9ydGVkKS5cbiAgICovXG4gIHJlYWRvbmx5IHN1bTogbnVtYmVyO1xuICAvKipcbiAgICogQSBsaXN0IG9mIHZhbHVlcyBhdCBkaWZmZXJlbnQgcGVyY2VudGlsZXMgb2YgdGhlIGRpc3RyaWJ1dGlvbiBjYWxjdWxhdGVkXG4gICAqIGZyb20gdGhlIGN1cnJlbnQgc25hcHNob3QuIFRoZSBwZXJjZW50aWxlcyBtdXN0IGJlIHN0cmljdGx5IGluY3JlYXNpbmcuXG4gICAqL1xuICByZWFkb25seSBwZXJjZW50aWxlVmFsdWVzOiBWYWx1ZUF0UGVyY2VudGlsZVtdO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHZhbHVlIGF0IGEgZ2l2ZW4gcGVyY2VudGlsZSBvZiBhIGRpc3RyaWJ1dGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWYWx1ZUF0UGVyY2VudGlsZSB7XG4gIC8qKiBUaGUgcGVyY2VudGlsZSBvZiBhIGRpc3RyaWJ1dGlvbi4gTXVzdCBiZSBpbiB0aGUgaW50ZXJ2YWwgKDAuMCwgMTAwLjBdLiAqL1xuICByZWFkb25seSBwZXJjZW50aWxlOiBudW1iZXI7XG4gIC8qKiBUaGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBlcmNlbnRpbGUgb2YgYSBkaXN0cmlidXRpb24uICovXG4gIHJlYWRvbmx5IHZhbHVlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGltZXN0YW1wIHtcbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgc2Vjb25kcyBvZiBVVEMgdGltZSBzaW5jZSBVbml4IGVwb2NoXG4gICAqIDE5NzAtMDEtMDFUMDA6MDA6MDBaLiBNdXN0IGJlIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG9cbiAgICogOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlLlxuICAgKi9cbiAgc2Vjb25kczogbnVtYmVyIHwgbnVsbDtcbiAgLyoqXG4gICAqIE5vbi1uZWdhdGl2ZSBmcmFjdGlvbnMgb2YgYSBzZWNvbmQgYXQgbmFub3NlY29uZCByZXNvbHV0aW9uLiBOZWdhdGl2ZVxuICAgKiBzZWNvbmQgdmFsdWVzIHdpdGggZnJhY3Rpb25zIG11c3Qgc3RpbGwgaGF2ZSBub24tbmVnYXRpdmUgbmFub3MgdmFsdWVzXG4gICAqIHRoYXQgY291bnQgZm9yd2FyZCBpbiB0aW1lLiBNdXN0IGJlIGZyb20gMCB0byA5OTksOTk5LDk5OVxuICAgKiBpbmNsdXNpdmUuXG4gICAqL1xuICBuYW5vczogbnVtYmVyIHwgbnVsbDtcbn1cblxuLyoqXG4gKiBLZWVwcyBhIHNldCBvZiBNZXRyaWNQcm9kdWNlciB0aGF0IGlzIHVzZWQgYnkgZXhwb3J0ZXJzIHRvIGRldGVybWluZSB0aGVcbiAqIG1ldHJpY3MgdGhhdCBuZWVkIHRvIGJlIGV4cG9ydGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1ldHJpY1Byb2R1Y2VyTWFuYWdlciB7XG4gIC8qKiBBZGRzIHRoZSBNZXRyaWNQcm9kdWNlciB0byB0aGUgbWFuYWdlciAqL1xuICBhZGQobWV0cmljUHJvZHVjZXI6IE1ldHJpY1Byb2R1Y2VyKTogdm9pZDtcbiAgLyoqIFJlbW92ZXMgdGhlIE1ldHJpY1Byb2R1Y2VyIHRvIHRoZSBtYW5hZ2VyICovXG4gIHJlbW92ZShtZXRyaWNQcm9kdWNlcjogTWV0cmljUHJvZHVjZXIpOiB2b2lkO1xuICAvKiogQ2xlYXJzIGFsbCBNZXRyaWNQcm9kdWNlcnMgKi9cbiAgcmVtb3ZlQWxsKCk6IHZvaWQ7XG4gIC8qKiBHZXRzIGFsbCByZWdpc3RlcmVkIE1ldHJpY1Byb2R1Y2VycyB0aGF0IHNob3VsZCBiZSBleHBvcnRlZCAqL1xuICBnZXRBbGxNZXRyaWNQcm9kdWNlcigpOiBTZXQ8TWV0cmljUHJvZHVjZXI+O1xufVxuXG4vKipcbiAqIEEgTWV0cmljUHJvZHVjZXIgcHJvZHVjZXIgdGhhdCBjYW4gYmUgcmVnaXN0ZXJlZCBmb3IgZXhwb3J0aW5nIHVzaW5nXG4gKiBNZXRyaWNQcm9kdWNlck1hbmFnZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWV0cmljUHJvZHVjZXIge1xuICAvKiogR2V0cyBhIGNvbGxlY3Rpb24gb2YgcHJvZHVjZWQgTWV0cmljYHMgdG8gYmUgZXhwb3J0ZWQgKi9cbiAgZ2V0TWV0cmljcygpOiBNZXRyaWNbXTtcbn1cbiJdLCJtYXBwaW5ncyI6ImFBQUE7Ozs7Ozs7Ozs7Ozs7O0dBQUEsU0FBQUEsZUFBQSxNQUFBQyxJQUFBLG1HQUFBQyxJQUFBLGdEQUFBQyxNQUFBLEtBQUFDLFFBQUEsc0JBQUFDLEdBQUEsb0JBQUFDLFlBQUEsRUFBQUwsSUFBQSwrRkFBQU0sWUFBQSxPQUFBQyxLQUFBLEVBQUFDLElBQUEsSUFBQUMsTUFBQSxJQUFBQyxHQUFBLEVBQUFGLElBQUEsSUFBQUMsTUFBQSxXQUFBRixLQUFBLEVBQUFDLElBQUEsSUFBQUMsTUFBQSxJQUFBQyxHQUFBLEVBQUFGLElBQUEsSUFBQUMsTUFBQSxXQUFBRixLQUFBLEVBQUFDLElBQUEsSUFBQUMsTUFBQSxJQUFBQyxHQUFBLEVBQUFGLElBQUEsSUFBQUMsTUFBQSxXQUFBRixLQUFBLEVBQUFDLElBQUEsSUFBQUMsTUFBQSxJQUFBQyxHQUFBLEVBQUFGLElBQUEsSUFBQUMsTUFBQSxXQUFBRixLQUFBLEVBQUFDLElBQUEsSUFBQUMsTUFBQSxJQUFBQyxHQUFBLEVBQUFGLElBQUEsSUFBQUMsTUFBQSxXQUFBRixLQUFBLEVBQUFDLElBQUEsSUFBQUMsTUFBQSxJQUFBQyxHQUFBLEVBQUFGLElBQUEsSUFBQUMsTUFBQSxXQUFBRixLQUFBLEVBQUFDLElBQUEsSUFBQUMsTUFBQSxJQUFBQyxHQUFBLEVBQUFGLElBQUEsSUFBQUMsTUFBQSxXQUFBRixLQUFBLEVBQUFDLElBQUEsSUFBQUMsTUFBQSxJQUFBQyxHQUFBLEVBQUFGLElBQUEsSUFBQUMsTUFBQSxXQUFBRixLQUFBLEVBQUFDLElBQUEsSUFBQUMsTUFBQSxJQUFBQyxHQUFBLEVBQUFGLElBQUEsSUFBQUMsTUFBQSxXQUFBRixLQUFBLEVBQUFDLElBQUEsSUFBQUMsTUFBQSxJQUFBQyxHQUFBLEVBQUFGLElBQUEsSUFBQUMsTUFBQSxhQUFBRixLQUFBLEVBQUFDLElBQUEsSUFBQUMsTUFBQSxJQUFBQyxHQUFBLEVBQUFGLElBQUEsSUFBQUMsTUFBQSxPQUFBRSxLQUFBLE9BQUFDLElBQUEsaUJBQUFDLElBQUEsRUFBQU4sS0FBQSxFQUFBQyxJQUFBLElBQUFDLE1BQUEsSUFBQUMsR0FBQSxFQUFBRixJQUFBLElBQUFDLE1BQUEsS0FBQUssR0FBQSxFQUFBUCxLQUFBLEVBQUFDLElBQUEsSUFBQUMsTUFBQSxLQUFBQyxHQUFBLEVBQUFGLElBQUEsSUFBQUMsTUFBQSxLQUFBRCxJQUFBLE1BQUFPLFNBQUEsT0FBQUQsR0FBQSxFQUFBUCxLQUFBLEVBQUFDLElBQUEsSUFBQUMsTUFBQSxLQUFBQyxHQUFBLEVBQUFGLElBQUEsSUFBQUMsTUFBQSxNQUFBTyxJQUFBLGVBQUFDLFNBQUEsR0FBQVYsS0FBQSxFQUFBQyxJQUFBLElBQUFDLE1BQUEsS0FBQUMsR0FBQSxFQUFBRixJQUFBLElBQUFDLE1BQUEsT0FBQUYsS0FBQSxFQUFBQyxJQUFBLElBQUFDLE1BQUEsS0FBQUMsR0FBQSxFQUFBRixJQUFBLElBQUFDLE1BQUEsT0FBQUQsSUFBQSxNQUFBVSxDQUFBLHNFQUFBQyxDQUFBLFNBQUFDLENBQUEsYUFBQUMsY0FBQSxFQUFBQyxPQUFBLEdBQUFDLElBQUEsK0ZBQUFDLE9BQUEsaUdBQUFDLEtBQUEsSUFBQUMsUUFBQSw4WEFBQUMsY0FBQSx1dlhBQUFDLGVBQUEsNENBQUEzQixJQUFBLGlEQUFBNEIsUUFBQSxDQUFBM0IsTUFBQSxDQUFBRSxHQUFBLElBQUFGLE1BQUEsQ0FBQUUsR0FBQSxVQUFBeUIsUUFBQSxDQUFBN0IsSUFBQSxHQUFBNkIsUUFBQSxDQUFBN0IsSUFBQSxFQUFBQyxJQUFBLEdBQUFBLElBQUEsRUFBQTRCLFFBQUEsQ0FBQTdCLElBQUEsRUFBQUssWUFBQSxNQUFBeUIsY0FBQSxDQUFBRCxRQUFBLENBQUE3QixJQUFBLEdBY0c7QUFBQUQsY0FBQSxTQUFBQSxDQUFBLFNBQUErQixjQUFBLFdBQUFBLGNBQUEsRUFBQS9CLGNBQUEsR0FBQUEsY0FBQSxHQUFBbUIsQ0FBQSxNLHFIQXNDSDs7Ozs7Ozs7OztHQVdBLEdBQVksQ0FBQWEsb0JBc0NYLENBQUFoQyxjQUFBLEdBQUFtQixDQUFBLE1BdENELFVBQVlhLG9CQUFvQixFQUFBaEMsY0FBQSxHQUFBb0IsQ0FBQSxNQUFBcEIsY0FBQSxHQUFBbUIsQ0FBQSxNQUM5QixxQ0FDQWEsb0JBQUEsQ0FBQUEsb0JBQUEsZ0NBQVcsQ0FDWCx3REFBQWhDLGNBQUEsR0FBQW1CLENBQUEsTUFDQWEsb0JBQUEsQ0FBQUEsb0JBQUEsZ0NBQVcsQ0FDWCwrREFBQWhDLGNBQUEsR0FBQW1CLENBQUEsTUFDQWEsb0JBQUEsQ0FBQUEsb0JBQUEsa0NBQVksQ0FDWjs7Ozs7T0FBQWhDLGNBQUEsR0FBQW1CLENBQUEsTUFNQWEsb0JBQUEsQ0FBQUEsb0JBQUEsOENBQWtCLENBQ2xCOzs7T0FBQWhDLGNBQUEsR0FBQW1CLENBQUEsTUFJQWEsb0JBQUEsQ0FBQUEsb0JBQUEsMENBQWdCLENBQ2hCOzs7O09BQUFoQyxjQUFBLEdBQUFtQixDQUFBLE1BS0FhLG9CQUFBLENBQUFBLG9CQUFBLDRDQUFpQixDQUNqQjs7O09BQUFoQyxjQUFBLEdBQUFtQixDQUFBLE1BSUFhLG9CQUFBLENBQUFBLG9CQUFBLHdEQUF1QixDQUN2Qjs7Ozs7O09BQUFoQyxjQUFBLEdBQUFtQixDQUFBLE9BT0FhLG9CQUFBLENBQUFBLG9CQUFBLHdCQUFPLENBQ1QsQ0FBQyxFQXRDV0Esb0JBQW9CLENBQXBCLENBQUFoQyxjQUFBLEdBQUFxQixDQUFBLFNBQUFZLE9BQUEsQ0FBQUQsb0JBQW9CLElBQUFoQyxjQUFBLEdBQUFxQixDQUFBLFNBQXBCWSxPQUFBLENBQUFELG9CQUFvQixNIn0=