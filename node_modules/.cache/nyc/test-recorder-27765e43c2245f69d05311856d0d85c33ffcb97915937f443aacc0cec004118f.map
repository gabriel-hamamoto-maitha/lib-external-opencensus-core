{"version":3,"file":"/Users/usermaitha/trademaster/libs/lib-external-opencensus-node/test/test-recorder.ts","sources":["/Users/usermaitha/trademaster/libs/lib-external-opencensus-node/test/test-recorder.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2018, OpenCensus Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as assert from 'assert';\nimport { Recorder, TagMap, TagTtl } from '../src';\nimport {\n  AggregationType,\n  CountData,\n  DistributionData,\n  LastValueData,\n  Measure,\n  Measurement,\n  MeasureType,\n  MeasureUnit,\n  SumData,\n} from '../src/stats/types';\n\n/** The order of how close values must be to be considerated almost equal */\nconst EPSILON = 6;\n\ninterface RecorderTestCase {\n  values: number[];\n  description: string;\n}\n\nfunction isAlmostEqual(\n  actual: number,\n  expected: number,\n  epsilon: number\n): boolean {\n  return Math.abs(actual - expected) < Math.pow(10, -epsilon);\n}\n\nfunction assertDistributionData(\n  distributionData: DistributionData,\n  values: number[]\n) {\n  const valuesSum = values.reduce((acc, cur) => acc + cur);\n\n  assert.strictEqual(distributionData.count, values.length);\n  assert.strictEqual(distributionData.sum, valuesSum);\n\n  const expectedMean = valuesSum / values.length;\n  assert.ok(isAlmostEqual(distributionData.mean, expectedMean, EPSILON));\n\n  const expectedSumSquaredDeviations = values\n    .map(value => Math.pow(value - expectedMean, 2))\n    .reduce((acc, curr) => acc + curr);\n  assert.ok(\n    isAlmostEqual(\n      distributionData.sumOfSquaredDeviation,\n      expectedSumSquaredDeviations,\n      EPSILON\n    )\n  );\n\n  const expectedStdDeviation = Math.sqrt(\n    expectedSumSquaredDeviations / values.length\n  );\n  assert.ok(\n    isAlmostEqual(distributionData.stdDeviation, expectedStdDeviation, EPSILON)\n  );\n}\n\ndescribe('Recorder', () => {\n  const measures: Measure[] = [\n    {\n      name: 'Test Measure 1',\n      type: MeasureType.DOUBLE,\n      unit: MeasureUnit.UNIT,\n    },\n    { name: 'Test Measure 2', type: MeasureType.INT64, unit: MeasureUnit.UNIT },\n  ];\n  const tagValues = [{ value: 'testValue' }];\n  const testCases: RecorderTestCase[] = [\n    { values: [1.1, 2.5, 3.2, 4.7, 5.2], description: 'with positive values' },\n    {\n      values: [-1.5, -2.3, -3.7, -4.3, -5.9],\n      description: 'with negative values',\n    },\n    { values: [0, 0, 0, 0], description: 'with zeros' },\n    { values: [1.1, -2.3, 3.2, -4.3, 5.2], description: 'with mixed values' },\n  ];\n\n  for (const measure of measures) {\n    describe(`for count aggregation data of ${measure.type} values`, () => {\n      for (const testCase of testCases) {\n        it(`should record measurements ${testCase.description} correctly`, () => {\n          const countData: CountData = {\n            type: AggregationType.COUNT,\n            tagValues,\n            timestamp: Date.now(),\n            value: 0,\n          };\n          let count = 0;\n          for (const value of testCase.values) {\n            count++;\n            const measurement: Measurement = { measure, value };\n            const updatedAggregationData = Recorder.addMeasurement(\n              countData,\n              measurement\n            ) as CountData;\n\n            assert.strictEqual(updatedAggregationData.value, count);\n          }\n        });\n      }\n    });\n\n    describe(`for last value aggregation data of ${measure.type} values`, () => {\n      for (const testCase of testCases) {\n        it(`should record measurements ${testCase.description} correctly`, () => {\n          const lastValueData: LastValueData = {\n            type: AggregationType.LAST_VALUE,\n            tagValues,\n            timestamp: Date.now(),\n            value: 0,\n          };\n          for (const value of testCase.values) {\n            const measurement: Measurement = { measure, value };\n            const lastValue =\n              measure.type === MeasureType.DOUBLE ? value : Math.trunc(value);\n\n            const updatedAggregationData = Recorder.addMeasurement(\n              lastValueData,\n              measurement\n            ) as LastValueData;\n            assert.strictEqual(updatedAggregationData.value, lastValue);\n          }\n        });\n      }\n    });\n\n    describe(`for sum aggregation data of ${measure.type} values`, () => {\n      for (const testCase of testCases) {\n        it(`should record measurements ${testCase.description} correctly`, () => {\n          const sumData: SumData = {\n            type: AggregationType.SUM,\n            tagValues,\n            timestamp: Date.now(),\n            value: 0,\n          };\n          let acc = 0;\n          for (const value of testCase.values) {\n            acc +=\n              measure.type === MeasureType.DOUBLE ? value : Math.trunc(value);\n            const measurement: Measurement = { measure, value };\n            const updatedAggregationData = Recorder.addMeasurement(\n              sumData,\n              measurement\n            ) as SumData;\n\n            assert.strictEqual(updatedAggregationData.value, acc);\n          }\n        });\n      }\n    });\n\n    describe(`for distribution aggregation data of ${measure.type} values`, () => {\n      for (const testCase of testCases) {\n        it(`should record measurements ${testCase.description} correctly`, () => {\n          const distributionData: DistributionData = {\n            type: AggregationType.DISTRIBUTION,\n            tagValues,\n            timestamp: Date.now(),\n            startTime: Date.now(),\n            count: 0,\n            sum: 0,\n            mean: 0,\n            stdDeviation: 0,\n            sumOfSquaredDeviation: 0,\n            buckets: [2, 4, 6],\n            bucketCounts: [0, 0, 0, 0],\n          };\n          const sentValues = [];\n          for (const value of testCase.values) {\n            sentValues.push(\n              measure.type === MeasureType.DOUBLE ? value : Math.trunc(value)\n            );\n            const measurement: Measurement = { measure, value };\n            const updatedAggregationData = Recorder.addMeasurement(\n              distributionData,\n              measurement\n            ) as DistributionData;\n            assertDistributionData(updatedAggregationData, sentValues);\n          }\n        });\n      }\n    });\n\n    describe('for distribution aggregation data with attachments', () => {\n      const attachments = { k1: 'v1', k2: 'v2', k3: 'v3' };\n      it('should record measurements and attachments correctly', () => {\n        const distributionData: DistributionData = {\n          type: AggregationType.DISTRIBUTION,\n          tagValues,\n          timestamp: Date.now(),\n          startTime: Date.now(),\n          count: 0,\n          sum: 0,\n          mean: 0,\n          stdDeviation: 0,\n          sumOfSquaredDeviation: 0,\n          buckets: [2, 4, 6],\n          bucketCounts: [0, 0, 0, 0],\n          exemplars: new Array(4),\n        };\n        const value = 5;\n        const measurement: Measurement = { measure, value };\n        const aggregationData = Recorder.addMeasurement(\n          distributionData,\n          measurement,\n          attachments\n        ) as DistributionData;\n\n        assert.strictEqual(aggregationData.sum, 5);\n        assert.strictEqual(aggregationData.mean, 5);\n        assert.deepStrictEqual(aggregationData.buckets, [2, 4, 6]);\n        assert.deepStrictEqual(aggregationData.bucketCounts, [0, 0, 1, 0]);\n        assert.deepStrictEqual(aggregationData.exemplars![0], undefined);\n        assert.deepStrictEqual(aggregationData.exemplars![1], undefined);\n        assert.deepStrictEqual(aggregationData!.exemplars![2], {\n          value: 5,\n          timestamp: aggregationData.timestamp,\n          attachments,\n        });\n        assert.deepStrictEqual(aggregationData.exemplars![3], undefined);\n      });\n    });\n\n    describe('getTagValues()', () => {\n      const CALLER = { name: 'caller' };\n      const METHOD = { name: 'method' };\n      const ORIGINATOR = { name: 'originator' };\n      const CALLER_V = { value: 'some caller' };\n      const METHOD_V = { value: 'some method' };\n      const ORIGINATOR_V = { value: 'some originator' };\n      const NO_PROPAGATION_MD = { tagTtl: TagTtl.NO_PROPAGATION };\n      const UNLIMITED_PROPAGATION_MD = { tagTtl: TagTtl.UNLIMITED_PROPAGATION };\n      let tagMap: TagMap;\n\n      beforeEach(() => {\n        tagMap = new TagMap();\n      });\n\n      it('should return tag values from tags and columns', () => {\n        const columns = [CALLER, METHOD];\n        tagMap.set(CALLER, CALLER_V);\n        tagMap.set(METHOD, METHOD_V);\n        const tagValues = Recorder.getTagValues(tagMap.tags, columns);\n        assert.strictEqual(tagValues.length, 2);\n        assert.deepStrictEqual(tagValues, [CALLER_V, METHOD_V]);\n      });\n\n      it('should return tag values from tags and columns when using metadata', () => {\n        const columns = [CALLER, METHOD];\n        tagMap.set(CALLER, CALLER_V, NO_PROPAGATION_MD);\n        tagMap.set(METHOD, METHOD_V, UNLIMITED_PROPAGATION_MD);\n        const tagValues = Recorder.getTagValues(tagMap.tags, columns);\n        assert.strictEqual(tagValues.length, 2);\n        assert.deepStrictEqual(tagValues, [CALLER_V, METHOD_V]);\n      });\n\n      it('should return tag values from tags and columns with extra keys', () => {\n        const columns = [CALLER, METHOD, ORIGINATOR];\n        tagMap.set(CALLER, CALLER_V);\n        tagMap.set(METHOD, METHOD_V);\n        const tagValues = Recorder.getTagValues(tagMap.tags, columns);\n        assert.strictEqual(tagValues.length, 3);\n        assert.deepStrictEqual(tagValues, [CALLER_V, METHOD_V, null]);\n      });\n\n      it('should return tag values from tags and columns with extra tags', () => {\n        const columns = [CALLER, METHOD];\n        tagMap.set(CALLER, CALLER_V);\n        tagMap.set(METHOD, METHOD_V);\n        tagMap.set(ORIGINATOR, ORIGINATOR_V);\n        const tagValues = Recorder.getTagValues(tagMap.tags, columns);\n        assert.strictEqual(tagValues.length, 2);\n        assert.deepStrictEqual(tagValues, [CALLER_V, METHOD_V]);\n      });\n    });\n  }\n});\n"]}