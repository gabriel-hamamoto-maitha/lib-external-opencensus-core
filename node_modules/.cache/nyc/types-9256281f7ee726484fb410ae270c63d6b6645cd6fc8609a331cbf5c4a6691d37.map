{"version":3,"file":"/Users/usermaitha/trademaster/libs/lib-external-opencensus-node/src/metrics/export/types.ts","sources":["/Users/usermaitha/trademaster/libs/lib-external-opencensus-node/src/metrics/export/types.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;;AAsCH;;;;;;;;;;GAUG;AACH,IAAY,oBAsCX;AAtCD,WAAY,oBAAoB;IAC9B,qCAAqC;IACrC,6EAAW,CAAA;IACX,wDAAwD;IACxD,6EAAW,CAAA;IACX,+DAA+D;IAC/D,+EAAY,CAAA;IACZ;;;;;OAKG;IACH,2FAAkB,CAAA;IAClB;;;OAGG;IACH,uFAAgB,CAAA;IAChB;;;;OAIG;IACH,yFAAiB,CAAA;IACjB;;;OAGG;IACH,qGAAuB,CAAA;IACvB;;;;;;OAMG;IACH,qEAAO,CAAA;AACT,CAAC,EAtCW,oBAAoB,GAApB,4BAAoB,KAApB,4BAAoB,QAsC/B","sourcesContent":["/**\n * Copyright 2018, OpenCensus Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** Properties of a Metric which has one or more timeseries */\nexport interface Metric {\n  /**\n   * The descriptor of the Metric. This is an optimization for network wire\n   * size, from data-model perspective a Metric contains always\n   * a MetricDescriptor.\n   * In case of a streaming RPC can be sent only\n   * the first time a metric is reported to save network traffic.\n   */\n  readonly descriptor: MetricDescriptor;\n  /**\n   * One or more timeseries for a single metric, where each timeseries has\n   * one or more points.\n   */\n  readonly timeseries: TimeSeries[];\n}\n\n/** Properties of a Metric type and its schema */\nexport interface MetricDescriptor {\n  /**  The metric type, including its DNS name prefix. It must be unique. */\n  readonly name: string;\n  /**\n   * A detailed description of the metric, which can be used in documentation.\n   */\n  readonly description: string;\n  /**\n   * The unit in which the metric value is reported. Follows the format\n   * described by http://unitsofmeasure.org/ucum.html.\n   */\n  readonly unit: string;\n  /** MetricDescriptor type */\n  readonly type: MetricDescriptorType;\n  /** The label keys associated with the metric descriptor. */\n  readonly labelKeys: LabelKey[];\n}\n\n/**\n * The kind of metric. It describes how the data is reported.\n *\n * A gauge is an instantaneous measurement of a value.\n *\n * A cumulative measurement is a value accumulated over a time interval. In\n * a time series, cumulative measurements should have the same start time,\n * increasing values and increasing end times, until an event resets the\n * cumulative value to zero and sets a new start time for the following\n * points.\n */\nexport enum MetricDescriptorType {\n  /** Do not use this default value. */\n  UNSPECIFIED,\n  /** Integer gauge. The value can go both up and down. */\n  GAUGE_INT64,\n  /** Floating point gauge. The value can go both up and down. */\n  GAUGE_DOUBLE,\n  /**\n   * Distribution gauge measurement. The count and sum can go both up and\n   * down. Recorded values are always >= 0.\n   * Used in scenarios like a snapshot of time the current items in a queue\n   * have spent there.\n   */\n  GAUGE_DISTRIBUTION,\n  /**\n   * Integer cumulative measurement. The value cannot decrease, if resets\n   * then the start_time should also be reset.\n   */\n  CUMULATIVE_INT64,\n  /**\n   * Floating point cumulative measurement. The value cannot decrease, if\n   * resets then the start_time should also be reset. Recorded values are\n   * always >= 0.\n   */\n  CUMULATIVE_DOUBLE,\n  /**\n   * Distribution cumulative measurement. The count and sum cannot decrease,\n   * if resets then the start_time should also be reset.\n   */\n  CUMULATIVE_DISTRIBUTION,\n  /**\n   * Some frameworks implemented Histograms as a summary of observations\n   * (usually things like request durations and response sizes). While it\n   * also provides a total count of observations and a sum of all observed\n   * values, it calculates configurable percentiles over a sliding time\n   * window. This is not recommended, since it cannot be aggregated.\n   */\n  SUMMARY,\n}\n\n/** Properties of a LabelKey associated with a MetricDescriptor. */\nexport interface LabelKey {\n  /** The key for the label. */\n  readonly key: string;\n  /** A human-readable description of what this label key represents. */\n  readonly description: string;\n}\n\n/**\n * A collection of data points that describes the time-varying values\n * of a metric.\n */\nexport interface TimeSeries {\n  /**\n   * Must be present for cumulative metrics. The time when the cumulative value\n   * was reset to zero. Exclusive. The cumulative value is over the time\n   * interval (start_timestamp, timestamp]. If not specified, the backend can\n   * use the previous recorded value.\n   */\n  readonly startTimestamp?: Timestamp;\n  /**\n   * The set of label values that uniquely identify this timeseries. Applies to\n   * all points. The order of label values must match that of label keys in the\n   * metric descriptor.\n   */\n  readonly labelValues: LabelValue[];\n  /**\n   * The data points of this timeseries. Point.value type MUST match the\n   * MetricDescriptor.type.\n   */\n  readonly points: Point[];\n}\n\n/** The LabelValue type. null value indicates an unset. */\nexport interface LabelValue {\n  /** The value for the label. */\n  readonly value: string | null;\n}\n\n/** A timestamped measurement. */\nexport interface Point {\n  /**\n   * The moment when this point was recorded. Inclusive.\n   * If not specified, the timestamp will be decided by the backend.\n   */\n  readonly timestamp: Timestamp;\n  /**\n   * The actual point value.\n   * 64-bit integer or 64-bit double-precision floating-point number\n   * or distribution value\n   * or summary value. This is not recommended, since it cannot be aggregated.\n   */\n  readonly value: number | DistributionValue | SummaryValue;\n}\n\n/**\n * Distribution contains summary statistics for a population of values. It\n * optionally contains a histogram representing the distribution of those\n * values across a set of buckets.\n */\nexport interface DistributionValue {\n  /**\n   * The number of values in the population. Must be non-negative. This value\n   * must equal the sum of the values in bucket_counts if a histogram is\n   * provided.\n   */\n  readonly count: number;\n  /**\n   * The sum of the values in the population. If count is zero then this field\n   * must be zero.\n   */\n  readonly sum: number;\n  /**\n   * The sum of squared deviations from the mean of the values in the\n   * population. For values x_i this is:\n   *\n   *     Sum[i=1..n]((x_i - mean)^2)\n   *\n   * Knuth, \"The Art of Computer Programming\", Vol. 2, page 323, 3rd edition\n   * describes Welford's method for accumulating this sum in one pass.\n   *\n   * If count is zero then this field must be zero.\n   */\n  readonly sumOfSquaredDeviation: number;\n  /**\n   * Don't change bucket boundaries within a TimeSeries if your backend doesn't\n   * support this. To save network bandwidth this field can be sent only the\n   * first time a metric is sent when using a streaming RPC.\n   */\n  readonly bucketOptions: BucketOptions;\n  /** DistributionValue buckets */\n  readonly buckets: Bucket[];\n}\n\n/**\n * Properties of a BucketOptions.\n * A Distribution may optionally contain a histogram of the values in the\n * population. The bucket boundaries for that histogram are described by\n * BucketOptions.\n *\n * If bucket_options has no type, then there is no histogram associated with\n * the Distribution.\n */\nexport interface BucketOptions {\n  /** Bucket with explicit bounds. */\n  readonly explicit: Explicit;\n}\n\n/**\n * Properties of an Explicit.\n * Specifies a set of buckets with arbitrary upper-bounds.\n * This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket\n * index i are:\n *\n * [0, bucket_bounds[i]) for i == 0\n * [bucket_bounds[i-1], bucket_bounds[i]) for 0 < i < N-1\n * [bucket_bounds[i-1], +infinity) for i == N-1\n */\nexport interface Explicit {\n  /** The values must be strictly increasing and > 0. */\n  readonly bounds: number[];\n  // TODO: If OpenMetrics decides to support (a, b] intervals we should add\n  // support for these by defining a boolean value here which decides what\n  // type of intervals to use.\n}\n\n/** Properties of a Bucket. */\nexport interface Bucket {\n  /**\n   * The number of values in each bucket of the histogram, as described in\n   * bucket_bounds.\n   */\n  readonly count: number;\n  /**\n   * If the distribution does not have a histogram, then omit this field.\n   */\n  readonly exemplar?: Exemplar;\n}\n\n/**\n * Exemplars are example points that may be used to annotate aggregated\n * Distribution values. They are metadata that gives information about a\n * particular value added to a Distribution bucket.\n */\nexport interface Exemplar {\n  /**\n   * Value of the exemplar point. It determines which bucket the exemplar\n   * belongs to.\n   */\n  readonly value: number;\n  /** The observation (sampling) time of the above value. */\n  readonly timestamp: Timestamp;\n  /** Contextual information about the example value. */\n  readonly attachments: { [key: string]: string };\n}\n\n/**\n * The start_timestamp only applies to the count and sum in the SummaryValue.\n */\nexport interface SummaryValue {\n  /**\n   * The total number of recorded values since start_time. Optional since\n   * some systems don't expose this.\n   */\n  readonly count: number;\n  /**\n   * The total sum of recorded values since start_time. Optional since some\n   * systems don't expose this. If count is zero then this field must be zero.\n   * This field must be unset if the sum is not available.\n   */\n  readonly sum: number;\n  /** Values calculated over an arbitrary time window. */\n  // TODO: Change it to required when Exemplar functionality will be added.\n  readonly snapshot?: Snapshot;\n}\n\n/**\n * The values in this message can be reset at arbitrary unknown times, with\n * the requirement that all of them are reset at the same time.\n */\nexport interface Snapshot {\n  /**\n   * The number of values in the snapshot. Optional since some systems don't\n   * expose this.\n   */\n  readonly count: number;\n  /**\n   * The sum of values in the snapshot. Optional since some systems don't\n   * expose this. If count is zero then this field must be zero or not set\n   * (if not supported).\n   */\n  readonly sum: number;\n  /**\n   * A list of values at different percentiles of the distribution calculated\n   * from the current snapshot. The percentiles must be strictly increasing.\n   */\n  readonly percentileValues: ValueAtPercentile[];\n}\n\n/**\n * Represents the value at a given percentile of a distribution.\n */\nexport interface ValueAtPercentile {\n  /** The percentile of a distribution. Must be in the interval (0.0, 100.0]. */\n  readonly percentile: number;\n  /** The value at the given percentile of a distribution. */\n  readonly value: number;\n}\n\nexport interface Timestamp {\n  /**\n   * Represents seconds of UTC time since Unix epoch\n   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n   * 9999-12-31T23:59:59Z inclusive.\n   */\n  seconds: number | null;\n  /**\n   * Non-negative fractions of a second at nanosecond resolution. Negative\n   * second values with fractions must still have non-negative nanos values\n   * that count forward in time. Must be from 0 to 999,999,999\n   * inclusive.\n   */\n  nanos: number | null;\n}\n\n/**\n * Keeps a set of MetricProducer that is used by exporters to determine the\n * metrics that need to be exported.\n */\nexport interface MetricProducerManager {\n  /** Adds the MetricProducer to the manager */\n  add(metricProducer: MetricProducer): void;\n  /** Removes the MetricProducer to the manager */\n  remove(metricProducer: MetricProducer): void;\n  /** Clears all MetricProducers */\n  removeAll(): void;\n  /** Gets all registered MetricProducers that should be exported */\n  getAllMetricProducer(): Set<MetricProducer>;\n}\n\n/**\n * A MetricProducer producer that can be registered for exporting using\n * MetricProducerManager.\n */\nexport interface MetricProducer {\n  /** Gets a collection of produced Metric`s to be exported */\n  getMetrics(): Metric[];\n}\n"]}