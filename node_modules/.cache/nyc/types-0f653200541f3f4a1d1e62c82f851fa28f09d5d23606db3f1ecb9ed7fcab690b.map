{"version":3,"file":"/Users/usermaitha/trademaster/libs/lib-external-opencensus-node/src/trace/model/types.ts","sources":["/Users/usermaitha/trademaster/libs/lib-external-opencensus-node/src/trace/model/types.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;;AA2BH,gDAAgD;AAChD,IAAY,aAoIX;AApID,WAAY,aAAa;IACvB;;OAEG;IACH,6CAAM,CAAA;IACN;;OAEG;IACH,2DAAa,CAAA;IACb;;;;;;OAMG;IACH,uDAAW,CAAA;IACX;;;;;OAKG;IACH,yEAAoB,CAAA;IACpB;;;;;;OAMG;IACH,2EAAqB,CAAA;IACrB;;OAEG;IACH,2DAAa,CAAA;IACb;;;OAGG;IACH,qEAAkB,CAAA;IAClB;;;;;;;OAOG;IACH,2EAAqB,CAAA;IACrB;;;OAGG;IACH,6EAAsB,CAAA;IACtB;;;;;;;;;;;;;;;;;;;;;OAqBG;IACH,+EAAuB,CAAA;IACvB;;;;;;OAMG;IACH,wDAAY,CAAA;IACZ;;;;;;;;;;;;;;;;OAgBG;IACH,kEAAiB,CAAA;IACjB;;OAEG;IACH,oEAAkB,CAAA;IAClB;;;;OAIG;IACH,0DAAa,CAAA;IACb;;;;;;;OAOG;IACH,gEAAgB,CAAA;IAChB;;OAEG;IACH,4DAAc,CAAA;IACd;;;OAGG;IACH,wEAAoB,CAAA;AACtB,CAAC,EApIW,aAAa,GAAb,qBAAa,KAAb,qBAAa,QAoIxB;AA6FD,iEAAiE;AACjE,IAAY,gBAOX;AAPD,WAAY,gBAAgB;IAC1B,0BAA0B;IAC1B,qEAAe,CAAA;IACf,gCAAgC;IAChC,uDAAQ,CAAA;IACR,oCAAoC;IACpC,+DAAY,CAAA;AACd,CAAC,EAPW,gBAAgB,GAAhB,wBAAgB,KAAhB,wBAAgB,QAO3B;AAED;;;GAGG;AACH,IAAY,QAaX;AAbD,WAAY,QAAQ;IAClB,kBAAkB;IAClB,qDAAe,CAAA;IACf;;;OAGG;IACH,2CAAU,CAAA;IACV;;;OAGG;IACH,2CAAU,CAAA;AACZ,CAAC,EAbW,QAAQ,GAAR,gBAAQ,KAAR,gBAAQ,QAanB;AAED;;;GAGG;AACH,IAAY,QAUX;AAVD,WAAY,QAAQ;IAClB;;;OAGG;IACH,qDAAe,CAAA;IACf,sDAAsD;IACtD,iEAAqB,CAAA;IACrB,uDAAuD;IACvD,mEAAsB,CAAA;AACxB,CAAC,EAVW,QAAQ,GAAR,gBAAQ,KAAR,gBAAQ,QAUnB","sourcesContent":["/**\n * Copyright 2018, OpenCensus Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as loggerTypes from '../../common/types';\nimport * as configTypes from '../config/types';\nimport { Propagation } from '../propagation/types';\nimport * as samplerTypes from '../sampler/types';\n\n/** Default type for functions */\n// tslint:disable:no-any\nexport type Func<T> = (...args: any[]) => T;\n\n/** Maps a label to a string, number or boolean. */\nexport interface Attributes {\n  [attributeKey: string]: string | number | boolean;\n}\n\n/**\n * The status of a Span by providing a standard CanonicalCode in conjunction\n * with an optional descriptive message.\n */\nexport interface Status {\n  /** The canonical code of this message. */\n  code: CanonicalCode;\n  /** A developer-facing error message. */\n  message?: string;\n}\n\n/** An enumeration of canonical status codes. */\nexport enum CanonicalCode {\n  /**\n   * Not an error; returned on success\n   */\n  OK = 0,\n  /**\n   * The operation was cancelled (typically by the caller).\n   */\n  CANCELLED = 1,\n  /**\n   * Unknown error.  An example of where this error may be returned is\n   * if a status value received from another address space belongs to\n   * an error-space that is not known in this address space.  Also\n   * errors raised by APIs that do not return enough error information\n   * may be converted to this error.\n   */\n  UNKNOWN = 2,\n  /**\n   * Client specified an invalid argument.  Note that this differs\n   * from FAILED_PRECONDITION.  INVALID_ARGUMENT indicates arguments\n   * that are problematic regardless of the state of the system\n   * (e.g., a malformed file name).\n   */\n  INVALID_ARGUMENT = 3,\n  /**\n   * Deadline expired before operation could complete.  For operations\n   * that change the state of the system, this error may be returned\n   * even if the operation has completed successfully.  For example, a\n   * successful response from a server could have been delayed long\n   * enough for the deadline to expire.\n   */\n  DEADLINE_EXCEEDED = 4,\n  /**\n   * Some requested entity (e.g., file or directory) was not found.\n   */\n  NOT_FOUND = 5,\n  /**\n   * Some entity that we attempted to create (e.g., file or directory)\n   * already exists.\n   */\n  ALREADY_EXISTS = 6,\n  /**\n   * The caller does not have permission to execute the specified\n   * operation.  PERMISSION_DENIED must not be used for rejections\n   * caused by exhausting some resource (use RESOURCE_EXHAUSTED\n   * instead for those errors).  PERMISSION_DENIED must not be\n   * used if the caller can not be identified (use UNAUTHENTICATED\n   * instead for those errors).\n   */\n  PERMISSION_DENIED = 7,\n  /**\n   * Some resource has been exhausted, perhaps a per-user quota, or\n   * perhaps the entire file system is out of space.\n   */\n  RESOURCE_EXHAUSTED = 8,\n  /**\n   * Operation was rejected because the system is not in a state\n   * required for the operation's execution.  For example, directory\n   * to be deleted may be non-empty, an rmdir operation is applied to\n   * a non-directory, etc.\n   *\n   * A litmus test that may help a service implementor in deciding\n   * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n   *\n   *  - Use UNAVAILABLE if the client can retry just the failing call.\n   *  - Use ABORTED if the client should retry at a higher-level\n   *    (e.g., restarting a read-modify-write sequence).\n   *  - Use FAILED_PRECONDITION if the client should not retry until\n   *    the system state has been explicitly fixed.  E.g., if an \"rmdir\"\n   *    fails because the directory is non-empty, FAILED_PRECONDITION\n   *    should be returned since the client should not retry unless\n   *    they have first fixed up the directory by deleting files from it.\n   *  - Use FAILED_PRECONDITION if the client performs conditional\n   *    REST Get/Update/Delete on a resource and the resource on the\n   *    server does not match the condition. E.g., conflicting\n   *    read-modify-write on the same resource.\n   */\n  FAILED_PRECONDITION = 9,\n  /**\n   * The operation was aborted, typically due to a concurrency issue\n   * like sequencer check failures, transaction aborts, etc.\n   *\n   * See litmus test above for deciding between FAILED_PRECONDITION,\n   * ABORTED, and UNAVAILABLE.\n   */\n  ABORTED = 10,\n  /**\n   * Operation was attempted past the valid range.  E.g., seeking or\n   * reading past end of file.\n   *\n   * Unlike INVALID_ARGUMENT, this error indicates a problem that may\n   * be fixed if the system state changes. For example, a 32-bit file\n   * system will generate INVALID_ARGUMENT if asked to read at an\n   * offset that is not in the range [0,2^32-1], but it will generate\n   * OUT_OF_RANGE if asked to read from an offset past the current\n   * file size.\n   *\n   * There is a fair bit of overlap between FAILED_PRECONDITION and\n   * OUT_OF_RANGE.  We recommend using OUT_OF_RANGE (the more specific\n   * error) when it applies so that callers who are iterating through\n   * a space can easily look for an OUT_OF_RANGE error to detect when\n   * they are done.\n   */\n  OUT_OF_RANGE = 11,\n  /**\n   * Operation is not implemented or not supported/enabled in this service.\n   */\n  UNIMPLEMENTED = 12,\n  /**\n   * Internal errors.  Means some invariants expected by underlying\n   * system has been broken.  If you see one of these errors,\n   * something is very broken.\n   */\n  INTERNAL = 13,\n  /**\n   * The service is currently unavailable.  This is a most likely a\n   * transient condition and may be corrected by retrying with\n   * a backoff.\n   *\n   * See litmus test above for deciding between FAILED_PRECONDITION,\n   * ABORTED, and UNAVAILABLE.\n   */\n  UNAVAILABLE = 14,\n  /**\n   * Unrecoverable data loss or corruption.\n   */\n  DATA_LOSS = 15,\n  /**\n   * The request does not have valid authentication credentials for the\n   * operation.\n   */\n  UNAUTHENTICATED = 16,\n}\n\n/** A text annotation with a set of attributes. */\nexport interface Annotation {\n  /** A user-supplied message describing the event. */\n  description: string;\n  /** A timestamp for the event event. */\n  timestamp: number;\n  /** A set of attributes on the annotation. */\n  attributes: Attributes;\n}\n\n/** An event describing a message sent/received between Spans. */\nexport interface MessageEvent {\n  /** A timestamp for the event. */\n  timestamp: number;\n  /** Indicates whether the message was sent or received. */\n  type: MessageEventType;\n  /**\n   * An identifier for the MessageEvent's message that can be used to match\n   * SENT and RECEIVED MessageEvents. Message event ids should start with 1 for\n   * both sent and received messages and increment by 1 for each message\n   * sent/received.\n   */\n  id: number;\n  /** The number of uncompressed bytes sent or received. */\n  uncompressedSize?: number;\n  /**\n   * The number of compressed bytes sent or received. If zero or\n   * undefined, assumed to be the same size as uncompressed.\n   */\n  compressedSize?: number;\n}\n\n/**\n * A pointer from the current span to another span in the same trace or in a\n * different trace.\n */\nexport interface Link {\n  /** The trace ID for a trace within a project. */\n  traceId: string;\n  /** The span ID for a span within a trace. */\n  spanId: string;\n  /** The relationship of the current span relative to the linked. */\n  type: LinkType;\n  /** A set of attributes on the link. */\n  attributes: Attributes;\n}\n\n/** Defines the trace options */\nexport interface TraceOptions {\n  /** Root span name */\n  name: string;\n  /** Trace context */\n  spanContext?: SpanContext;\n  /** Span kind */\n  kind?: SpanKind;\n  /** Determines the sampling rate. Ranges from 0.0 to 1.0 */\n  samplingRate?: number;\n}\n\n/** Defines the span options */\nexport interface SpanOptions {\n  /** Span name */\n  name: string;\n  /** Span kind */\n  kind?: SpanKind;\n  /** The new span's parent */\n  childOf?: Span;\n}\n\nexport type TraceState = string;\n\n/** Defines the span context */\nexport interface SpanContext {\n  /** Trace ID */\n  traceId: string;\n  /** Span ID */\n  spanId: string;\n  /** Options */\n  options?: number;\n  /** TraceState */\n  traceState?: TraceState;\n}\n\n/** Defines an end span event listener */\nexport interface SpanEventListener {\n  /** Happens when a span is started */\n  onStartSpan(span: Span): void;\n  /** Happens when a span is ended */\n  onEndSpan(span: Span): void;\n}\n\n/** An event describing a message sent/received between Spans. */\nexport enum MessageEventType {\n  /** Unknown event type. */\n  UNSPECIFIED = 0,\n  /** Indicates a sent message. */\n  SENT = 1,\n  /** Indicates a received message. */\n  RECEIVED = 2,\n}\n\n/**\n * Type of span. Can be used to specify additional relationships between spans\n * in addition to a parent/child relationship.\n */\nexport enum SpanKind {\n  /** Unspecified */\n  UNSPECIFIED = 0,\n  /**\n   * Indicates that the span covers server-side handling of an RPC or other\n   * remote network request.\n   */\n  SERVER = 1,\n  /**\n   * Indicates that the span covers the client-side wrapper around an RPC or\n   * other remote request.\n   */\n  CLIENT = 2,\n}\n\n/**\n * Type of link. The relationship of the current span relative to the linked\n * span.\n */\nexport enum LinkType {\n  /**\n   * The relationship of the two spans is unknown, or known but other\n   * than parent-child.\n   */\n  UNSPECIFIED = 0,\n  /** The linked span is a child of the current span. */\n  CHILD_LINKED_SPAN = 1,\n  /** The linked span is a parent of the current span. */\n  PARENT_LINKED_SPAN = 2,\n}\n\n/** Interface for Span */\nexport interface Span {\n  /** The Span ID of this span */\n  readonly id: string;\n\n  /** A tracer object, exposong the tracer makes it possible to create child\n   * spans from the span instance like. span.tracer.startChildSpan()\n   */\n  tracer: TracerBase;\n\n  /** If the parent span is in another process. */\n  remoteParent: boolean;\n\n  /** The span ID of this span's parent. If it's a root span, must be empty */\n  parentSpanId: string;\n\n  /** The resource name of the span */\n  name: string;\n\n  /** Kind of span. */\n  kind: SpanKind;\n\n  /** An object to log information to */\n  logger: loggerTypes.Logger;\n\n  /** A final status for this span */\n  status: Status;\n\n  /** A set of attributes, each in the format [KEY]:[VALUE] */\n  attributes: Attributes;\n\n  /** A text annotation with a set of attributes. */\n  annotations: Annotation[];\n\n  /** An event describing a message sent/received between Spans. */\n  messageEvents: MessageEvent[];\n\n  /** Pointers from the current span to another span */\n  links: Link[];\n\n  /** Recursively gets the descendant spans. */\n  allDescendants(): Span[];\n\n  /** The list of immediate child spans. */\n  spans: Span[];\n\n  /** The number of direct children */\n  numberOfChildren: number;\n\n  /** Trace id asscoiated with span. */\n  readonly traceId: string;\n\n  /** Trace state associated with span */\n  readonly traceState?: TraceState;\n\n  /** Indicates if span was started. */\n  readonly started: boolean;\n\n  /** Indicates if span was ended. */\n  readonly ended: boolean;\n\n  /**\n   * Gives a timestap that indicates the span's start time in RFC3339 UTC\n   * \"Zulu\" format.\n   */\n  readonly startTime: Date;\n\n  /**\n   * Gives a timestap that indicates the span's end time in RFC3339 UTC\n   * \"Zulu\" format.\n   */\n  readonly endTime: Date;\n\n  /**\n   * Gives a timestap that indicates the span's duration in RFC3339 UTC\n   * \"Zulu\" format.\n   */\n  readonly duration: number;\n\n  /** Gives the TraceContext of the span. */\n  readonly spanContext: SpanContext;\n\n  /** Trace Parameters */\n  activeTraceParams: configTypes.TraceParams;\n\n  /** The number of dropped attributes. */\n  droppedAttributesCount: number;\n\n  /** The number of dropped links. */\n  droppedLinksCount: number;\n\n  /** The number of dropped annotations. */\n  droppedAnnotationsCount: number;\n\n  /** The number of dropped message events. */\n  droppedMessageEventsCount: number;\n\n  /**\n   * Adds an atribute to the span.\n   * @param key Describes the value added.\n   * @param value The result of an operation.\n   */\n  addAttribute(key: string, value: string | number | boolean | object): void;\n\n  /**\n   * Adds an annotation to the span.\n   * @param description Describes the event.\n   * @param attributes A set of attributes on the annotation.\n   * @param timestamp A timestamp for this event.\n   */\n  addAnnotation(\n    description: string,\n    attributes?: Attributes,\n    timestamp?: number\n  ): void;\n\n  /**\n   * Adds a link to the span.\n   * @param traceId The trace ID for a trace within a project.\n   * @param spanId The span ID for a span within a trace.\n   * @param type The relationship of the current span relative to the linked.\n   * @param attributes A set of attributes on the link.\n   */\n  addLink(\n    traceId: string,\n    spanId: string,\n    type: LinkType,\n    attributes?: Attributes\n  ): void;\n\n  /**\n   * Adds a message event to the span.\n   * @param type The type of message event.\n   * @param id An identifier for the message event.\n   * @param timestamp A timestamp for this event.\n   * @param uncompressedSize The number of uncompressed bytes sent or received.\n   * @param compressedSize The number of compressed bytes sent or received. If\n   *     zero or undefined, assumed to be the same size as uncompressed.\n   */\n  addMessageEvent(\n    type: MessageEventType,\n    id: number,\n    timestamp?: number,\n    uncompressedSize?: number,\n    compressedSize?: number\n  ): void;\n\n  /**\n   * Sets a status to the span.\n   * @param code The canonical status code.\n   * @param message optional A developer-facing error message.\n   */\n  setStatus(code: CanonicalCode, message?: string): void;\n\n  /** Starts a span. */\n  start(): void;\n\n  /** Ends a span and all of its children, recursively. */\n  end(): void;\n\n  /** Forces to end a span. */\n  truncate(): void;\n\n  /** Starts a new Span instance as a child of this instance */\n  startChildSpan(options?: SpanOptions): Span;\n\n  /** Returns whether a span is root or not. */\n  isRootSpan(): boolean;\n}\n\n/** Interface for TracerBase */\nexport interface TracerBase extends SpanEventListener {\n  /** A sampler that will decide if the span will be sampled or not */\n  sampler: samplerTypes.Sampler;\n\n  /** A configuration for starting the tracer */\n  logger: loggerTypes.Logger;\n\n  /** A configuration object for trace parameters */\n  activeTraceParams: configTypes.TraceParams;\n\n  /** A propagation instance */\n  readonly propagation: Propagation;\n\n  /** Get the eventListeners from tracer instance */\n  readonly eventListeners: SpanEventListener[];\n\n  /** Get the active status from tracer instance */\n  readonly active: boolean;\n\n  /**\n   * Start a tracer instance\n   * @param config Configuration for tracer instace\n   * @returns A tracer instance started\n   */\n  start(config: configTypes.TracerConfig): this;\n\n  /** Stop the tracer instance */\n  stop(): this;\n\n  /**\n   * Start a new RootSpan to currentRootSpan\n   * @param options Options for tracer instance\n   * @param fn Callback function\n   * @returns The callback return\n   */\n  startRootSpan<T>(options: TraceOptions, fn: (root: Span) => T): T;\n\n  /**\n   * Register a OnEndSpanEventListener on the tracer instance\n   * @param listener An OnEndSpanEventListener instance\n   */\n  registerSpanEventListener(listener: SpanEventListener): void;\n\n  /**\n   * Unregisters an end span event listener.\n   * @param listener The listener to unregister.\n   */\n  unregisterSpanEventListener(listener: SpanEventListener): void;\n\n  /**\n   * Start a new Span instance to the currentRootSpan\n   * @param [options] A TraceOptions object to start a root span.\n   * @returns The new Span instance started\n   */\n  startChildSpan(options?: SpanOptions): Span;\n\n  /** Sets the current root span. */\n  setCurrentRootSpan(root: Span): void;\n}\n\n/** Interface for Tracer */\nexport interface Tracer extends TracerBase {\n  /** Get and set the currentRootSpan to tracer instance */\n  currentRootSpan: Span;\n\n  /** Clear the currentRootSpan from tracer instance */\n  clearCurrentTrace(): void;\n\n  /**\n   * Binds the trace context to the given function.\n   * This is necessary in order to create child spans correctly in functions\n   * that are called asynchronously (for example, in a network response\n   * handler).\n   * @param fn A function to which to bind the trace context.\n   */\n  wrap<T>(fn: Func<T>): Func<T>;\n\n  /**\n   * Binds the trace context to the given event emitter.\n   * This is necessary in order to create child spans correctly in event\n   * handlers.\n   * @param emitter An event emitter whose handlers should have\n   *     the trace context binded to them.\n   */\n  wrapEmitter(emitter: NodeJS.EventEmitter): void;\n}\n"]}