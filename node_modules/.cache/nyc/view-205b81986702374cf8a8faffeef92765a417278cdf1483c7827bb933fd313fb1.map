{"version":3,"file":"/Users/usermaitha/trademaster/libs/lib-external-opencensus-node/src/stats/view.ts","sources":["/Users/usermaitha/trademaster/libs/lib-external-opencensus-node/src/stats/view.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2018, OpenCensus Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as defaultLogger from '../common/console-logger';\nimport {\n  getTimestampWithProcessHRTime,\n  timestampFromMillis,\n} from '../common/time-util';\nimport * as loggerTypes from '../common/types';\nimport {\n  Bucket as metricBucket,\n  DistributionValue,\n  LabelValue,\n  Metric,\n  MetricDescriptor,\n  MetricDescriptorType,\n  Point,\n  TimeSeries,\n  Timestamp,\n} from '../metrics/export/types';\nimport { TagMap } from '../tags/tag-map';\nimport { TagKey, TagValue } from '../tags/types';\nimport { isValidTagKey } from '../tags/validation';\nimport { BucketBoundaries } from './bucket-boundaries';\nimport { MetricUtils } from './metric-utils';\nimport { Recorder } from './recorder';\nimport {\n  AggregationData,\n  AggregationType,\n  Measure,\n  Measurement,\n  StatsExemplar,\n  View,\n} from './types';\n\nconst RECORD_SEPARATOR = String.fromCharCode(30);\n\n/**\n * A View specifies an aggregation and a set of tag keys. The aggregation will\n * be broken down by the unique set of matching tag values for each measure.\n */\nexport class BaseView implements View {\n  /**\n   * A string by which the View will be referred to, e.g. \"rpc_latency\". Names\n   * MUST be unique within the library.\n   */\n  readonly name: string;\n  /** Describes the view, e.g. \"RPC latency distribution\" */\n  readonly description: string;\n  /** The Measure to which this view is applied. */\n  readonly measure: Measure;\n  /**\n   * A map of stringified tags representing columns labels or tag keys, concept\n   * similar to dimensions on multidimensional modeling, to AggregationData.\n   * If no Tags are provided, then, all data is recorded in a single\n   * aggregation.\n   */\n  private tagValueAggregationMap: { [key: string]: AggregationData } = {};\n  /**\n   * A list of tag keys that represents the possible column labels\n   */\n  private columns: TagKey[];\n  /**\n   * An Aggregation describes how data collected is aggregated.\n   * There are four aggregation types: count, sum, lastValue and distirbution.\n   */\n  readonly aggregation: AggregationType;\n  /** The start time for this view */\n  readonly startTime: number;\n  /** The bucket boundaries in a Distribution Aggregation */\n  private bucketBoundaries?: BucketBoundaries;\n  /**\n   * Cache a MetricDescriptor to avoid converting View to MetricDescriptor\n   * in the future.\n   */\n  private metricDescriptor: MetricDescriptor;\n  /**\n   * The end time for this view - represents the last time a value was recorded\n   */\n  endTime?: number;\n  /** true if the view was registered */\n  registered = false;\n  /** An object to log information to */\n  logger: loggerTypes.Logger;\n\n  /**\n   * Creates a new View instance. This constructor is used by Stats. User should\n   * prefer using Stats.createView() instead.\n   * @param name The view name\n   * @param measure The view measure\n   * @param aggregation The view aggregation type\n   * @param tagsKeys The Tags' keys that view will have\n   * @param description The view description\n   * @param bucketBoundaries The view bucket boundaries for a distribution\n   *     aggregation type\n   * @param logger\n   */\n  constructor(\n    name: string,\n    measure: Measure,\n    aggregation: AggregationType,\n    tagsKeys: TagKey[],\n    description: string,\n    bucketBoundaries?: number[],\n    logger = defaultLogger\n  ) {\n    if (aggregation === AggregationType.DISTRIBUTION && !bucketBoundaries) {\n      throw new Error('No bucketBoundaries specified');\n    }\n    this.logger = logger.logger();\n    this.name = name;\n    this.description = description;\n    this.measure = measure;\n    this.columns = this.validateTagKeys(tagsKeys);\n    this.aggregation = aggregation;\n    this.startTime = Date.now();\n    if (bucketBoundaries) {\n      this.bucketBoundaries = new BucketBoundaries(bucketBoundaries);\n    }\n    this.metricDescriptor = MetricUtils.viewToMetricDescriptor(this);\n  }\n\n  /** Gets the view's tag keys */\n  getColumns(): TagKey[] {\n    return this.columns;\n  }\n\n  /**\n   * Records a measurement in the proper view's row. This method is used by\n   * Stats. User should prefer using Stats.record() instead.\n   *\n   * Measurements with measurement type INT64 will have its value truncated.\n   * @param measurement The measurement to record\n   * @param tags The tags to which the value is applied\n   * @param attachments optional The contextual information associated with an\n   *     example value. The contextual information is represented as key - value\n   *     string pairs.\n   */\n  recordMeasurement(\n    measurement: Measurement,\n    tags: TagMap,\n    attachments?: { [key: string]: string }\n  ) {\n    const tagValues = Recorder.getTagValues(tags.tags, this.columns);\n    const encodedTags = this.encodeTagValues(tagValues);\n    if (!this.tagValueAggregationMap[encodedTags]) {\n      this.tagValueAggregationMap[encodedTags] = this.createAggregationData(\n        tagValues\n      );\n    }\n\n    Recorder.addMeasurement(\n      this.tagValueAggregationMap[encodedTags],\n      measurement,\n      attachments\n    );\n  }\n\n  /**\n   * Encodes a TagValue object into a value sorted string.\n   * @param tagValues The tagValues to encode\n   */\n  private encodeTagValues(tagValues: Array<TagValue | null>): string {\n    return tagValues\n      .map(tagValue => (tagValue ? tagValue.value : null))\n      .sort()\n      .join(RECORD_SEPARATOR);\n  }\n\n  /**\n   * Creates an empty aggregation data for a given tags.\n   * @param tagValues The tags for that aggregation data\n   */\n  private createAggregationData(\n    tagValues: Array<TagValue | null>\n  ): AggregationData {\n    const aggregationMetadata = { tagValues, timestamp: Date.now() };\n\n    switch (this.aggregation) {\n      case AggregationType.DISTRIBUTION:\n        const { buckets, bucketCounts } = this.bucketBoundaries!;\n        const bucketsCopy = Object.assign([], buckets);\n        const bucketCountsCopy = Object.assign([], bucketCounts);\n        const exemplars = new Array(bucketCounts.length);\n\n        return {\n          ...aggregationMetadata,\n          type: AggregationType.DISTRIBUTION,\n          startTime: this.startTime,\n          count: 0,\n          sum: 0,\n          mean: 0,\n          stdDeviation: 0,\n          sumOfSquaredDeviation: 0,\n          buckets: bucketsCopy,\n          bucketCounts: bucketCountsCopy,\n          exemplars,\n        };\n      case AggregationType.SUM:\n        return { ...aggregationMetadata, type: AggregationType.SUM, value: 0 };\n      case AggregationType.COUNT:\n        return {\n          ...aggregationMetadata,\n          type: AggregationType.COUNT,\n          value: 0,\n        };\n      default:\n        return {\n          ...aggregationMetadata,\n          type: AggregationType.LAST_VALUE,\n          value: 0,\n        };\n    }\n  }\n\n  /**\n   * Gets view`s metric\n   * @param start The start timestamp in epoch milliseconds\n   * @returns The Metric.\n   */\n  getMetric(start: number): Metric {\n    const { type } = this.metricDescriptor;\n    let startTimestamp: Timestamp;\n\n    // The moment when this point was recorded.\n    const now: Timestamp = getTimestampWithProcessHRTime();\n    if (\n      type !== MetricDescriptorType.GAUGE_INT64 &&\n      type !== MetricDescriptorType.GAUGE_DOUBLE\n    ) {\n      startTimestamp = timestampFromMillis(start);\n    }\n\n    const timeseries: TimeSeries[] = [];\n    Object.keys(this.tagValueAggregationMap).forEach(key => {\n      const { tagValues } = this.tagValueAggregationMap[key];\n      const labelValues: LabelValue[] = MetricUtils.tagValuesToLabelValues(\n        tagValues\n      );\n      const point: Point = this.toPoint(now, this.getSnapshot(tagValues));\n\n      if (startTimestamp) {\n        timeseries.push({ startTimestamp, labelValues, points: [point] });\n      } else {\n        timeseries.push({ labelValues, points: [point] });\n      }\n    });\n\n    return { descriptor: this.metricDescriptor, timeseries };\n  }\n\n  /**\n   * Converts snapshot to point\n   * @param timestamp The timestamp\n   * @param data The aggregated data\n   * @returns The Point.\n   */\n  private toPoint(timestamp: Timestamp, data: AggregationData): Point {\n    if (data.type === AggregationType.DISTRIBUTION) {\n      const { count, sum, sumOfSquaredDeviation, exemplars } = data;\n      const buckets = [];\n      if (data.bucketCounts) {\n        for (let bucket = 0; bucket < data.bucketCounts.length; bucket++) {\n          const bucketCount = data.bucketCounts[bucket];\n          const statsExemplar = exemplars ? exemplars[bucket] : undefined;\n          buckets.push(this.getMetricBucket(bucketCount, statsExemplar));\n        }\n      }\n      const value: DistributionValue = {\n        count,\n        sum,\n        sumOfSquaredDeviation,\n        buckets,\n        bucketOptions: { explicit: { bounds: data.buckets } },\n      };\n      return { timestamp, value };\n    } else {\n      const value: number = data.value;\n      return { timestamp, value };\n    }\n  }\n\n  /**\n   * Returns a snapshot of an AggregationData for that tags/labels values.\n   * @param tags The desired data's tags\n   * @returns The AggregationData.\n   */\n  getSnapshot(tagValues: Array<TagValue | null>): AggregationData {\n    return this.tagValueAggregationMap[this.encodeTagValues(tagValues)];\n  }\n\n  /** Returns a Bucket with count and examplar (if present) */\n  private getMetricBucket(\n    bucketCount: number,\n    statsExemplar?: StatsExemplar\n  ): metricBucket {\n    if (statsExemplar) {\n      // Bucket with an Exemplar.\n      return {\n        count: bucketCount,\n        exemplar: {\n          value: statsExemplar.value,\n          timestamp: timestampFromMillis(statsExemplar.timestamp),\n          attachments: statsExemplar.attachments,\n        },\n      };\n    }\n    // Bucket with no Exemplar.\n    return { count: bucketCount };\n  }\n\n  /** Determines whether the given TagKeys are valid. */\n  private validateTagKeys(tagKeys: TagKey[]): TagKey[] {\n    const tagKeysCopy = Object.assign([], tagKeys);\n    tagKeysCopy.forEach(tagKey => {\n      if (!isValidTagKey(tagKey)) {\n        throw new Error(`Invalid TagKey name: ${tagKey}`);\n      }\n    });\n    const tagKeysSet = new Set(\n      tagKeysCopy.map((tagKey: TagKey) => tagKey.name)\n    );\n    if (tagKeysSet.size !== tagKeysCopy.length) {\n      throw new Error('Columns have duplicate');\n    }\n    return tagKeysCopy;\n  }\n}\n"]}