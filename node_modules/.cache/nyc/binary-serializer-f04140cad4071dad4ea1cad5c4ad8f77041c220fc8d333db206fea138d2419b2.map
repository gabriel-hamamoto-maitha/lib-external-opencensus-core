{"version":3,"file":"/Users/usermaitha/trademaster/libs/lib-external-opencensus-node/src/tags/propagation/binary-serializer.ts","sources":["/Users/usermaitha/trademaster/libs/lib-external-opencensus-node/src/tags/propagation/binary-serializer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2019, OpenCensus Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * This module contains the functions for serializing and deserializing\n * TagMap (TagContext) with the binary format. It allows tags to propagate\n * across requests.\n *\n * <p>OpenCensus tag context encoding:\n *\n * <ul>\n *   <li>Tags are encoded in single byte sequence. The version 0 format is:\n *   <li>{@code <version_id><encoded_tags>}\n *   <li>{@code <version_id> -> a single byte, value 0}\n *   <li>{@code <encoded_tags> -> (<tag_field_id><tag_encoding>)*}\n *     <ul>\n *       <li>{@code <tag_field_id>} -> a single byte, value 0\n *       <li>{@code <tag_encoding>}:\n *         <ul>\n *           <li>{@code <tag_key_len><tag_key><tag_val_len><tag_val>}\n *             <ul>\n *               <li>{@code <tag_key_len>} -> varint encoded integer\n *               <li>{@code <tag_key>} -> tag_key_len bytes comprising tag name\n *               <li>{@code <tag_val_len>} -> varint encoded integer\n *               <li>{@code <tag_val>} -> tag_val_len bytes comprising tag value\n *             </ul>\n *           </li>\n *         </ul>\n *       </li>\n *     </ul>\n * </ul>\n */\n\nimport { TagMap } from '../tag-map';\nimport { TagKey, TagValue } from '../types';\nimport { DecodeVarint, EncodeVarint } from './variant-encoding';\n\n// This size limit only applies to the bytes representing tag keys and values.\nexport const TAG_MAP_SERIALIZED_SIZE_LIMIT = 8192;\n\nconst ENCODING = 'utf8';\nconst VERSION_ID = 0;\nconst TAG_FIELD_ID = 0;\nconst VERSION_ID_INDEX = 0;\n\n/**\n * Serializes a given TagMap to the on-the-wire format.\n * @param tagMap The TagMap to serialize.\n */\nexport function serializeBinary(tagMap: TagMap): Buffer {\n  const byteArray: number[] = [];\n  byteArray.push(VERSION_ID);\n  let totalChars = 0;\n  const tags = tagMap.tags;\n  tags.forEach((tagValue: TagValue, tagKey: TagKey) => {\n    totalChars += tagKey.name.length;\n    totalChars += tagValue.value.length;\n    encodeTag(tagKey, tagValue, byteArray);\n  });\n\n  if (totalChars > TAG_MAP_SERIALIZED_SIZE_LIMIT) {\n    throw new Error(\n      `Size of TagMap exceeds the maximum serialized size ${TAG_MAP_SERIALIZED_SIZE_LIMIT}`\n    );\n  }\n  return Buffer.from(byteArray);\n}\n\n/**\n * Deserializes input to TagMap based on the binary format standard.\n * @param buffer The TagMap to deserialize.\n */\nexport function deserializeBinary(buffer: Buffer): TagMap {\n  if (buffer.length === 0) {\n    throw new Error('Input buffer can not be empty.');\n  }\n  const versionId = buffer.readInt8(VERSION_ID_INDEX);\n  if (versionId > VERSION_ID) {\n    throw new Error(\n      `Wrong Version ID: ${versionId}. Currently supports version up to: ${VERSION_ID}`\n    );\n  }\n  return parseTags(buffer);\n}\n\nfunction encodeTag(tagKey: TagKey, tagValue: TagValue, byteArray: number[]) {\n  byteArray.push(TAG_FIELD_ID);\n  encodeString(tagKey.name, byteArray);\n  encodeString(tagValue.value, byteArray);\n}\n\nfunction encodeString(input: string, byteArray: number[]) {\n  byteArray.push(...EncodeVarint(input.length));\n  byteArray.push(...input.split('').map(unicode));\n  return byteArray;\n}\n\nfunction parseTags(buffer: Buffer): TagMap {\n  const tags = new TagMap();\n  const limit = buffer.length;\n  let totalChars = 0;\n  let currentIndex = 1;\n\n  while (currentIndex < limit) {\n    const fieldId = buffer.readInt8(currentIndex);\n    if (fieldId > TAG_FIELD_ID) {\n      // Stop parsing at the first unknown field ID, since there is no way to\n      // know its length.\n      break;\n    }\n    currentIndex += 1;\n    const key = decodeString(buffer, currentIndex);\n    currentIndex += key.length;\n    totalChars += key.length;\n\n    currentIndex += 1;\n    const val = decodeString(buffer, currentIndex);\n    currentIndex += val.length;\n    totalChars += val.length;\n\n    currentIndex += 1;\n    if (totalChars > TAG_MAP_SERIALIZED_SIZE_LIMIT) {\n      throw new Error(\n        `Size of TagMap exceeds the maximum serialized size ${TAG_MAP_SERIALIZED_SIZE_LIMIT}`\n      );\n    } else {\n      tags.set({ name: key }, { value: val });\n    }\n  }\n  return tags;\n}\n\nfunction decodeString(buffer: Buffer, offset: number): string {\n  const length = DecodeVarint(buffer, offset);\n  return buffer.toString(ENCODING, offset + 1, offset + 1 + length);\n}\n\nfunction unicode(x: string) {\n  return x.charCodeAt(0);\n}\n"]}