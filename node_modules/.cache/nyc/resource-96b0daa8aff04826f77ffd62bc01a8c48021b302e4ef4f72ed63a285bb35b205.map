{"version":3,"file":"/Users/usermaitha/trademaster/libs/lib-external-opencensus-node/src/resource/resource.ts","sources":["/Users/usermaitha/trademaster/libs/lib-external-opencensus-node/src/resource/resource.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;;AAEH,2DAAuD;AAGvD;;;;;;GAMG;AACH,MAAa,YAAY;IAyBvB;;;;;OAKG;IACH,MAAM,CAAC,8BAA8B;QACnC,OAAO,EAAE,IAAI,EAAE,YAAY,CAAC,QAAQ,EAAE,MAAM,EAAE,YAAY,CAAC,aAAa,EAAE,CAAC;IAC7E,CAAC;IAED;;;;;;;OAOG;IACH,MAAM,CAAC,cAAc,CAAC,SAAqB;QACzC,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC;YAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC;QAClE,IAAI,eAAe,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;QACnC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACzC,eAAe,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;SAC7D;QACD,OAAO,eAAe,CAAC;IACzB,CAAC;IAED;;;;;;;;OAQG;IACK,MAAM,CAAC,iBAAiB,CAAC,UAAmB;QAClD,IAAI,CAAC,UAAU;YAAE,OAAO,IAAI,CAAC;QAC7B,IAAI,CAAC,YAAY,CAAC,kBAAkB,CAAC,UAAU,CAAC,EAAE;YAChD,MAAM,IAAI,KAAK,CAAC,QAAQ,YAAY,CAAC,2BAA2B,EAAE,CAAC,CAAC;SACrE;QACD,OAAO,UAAU,CAAC,IAAI,EAAE,CAAC;IAC3B,CAAC;IAED;;;;;;;;;;;OAWG;IACK,MAAM,CAAC,mBAAmB,CAAC,YAAqB;QACtD,IAAI,CAAC,YAAY;YAAE,OAAO,EAAE,CAAC;QAE7B,MAAM,MAAM,GAAW,EAAE,CAAC;QAC1B,MAAM,SAAS,GAAa,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC,CAAC,CAAC,CAAC;QACzE,KAAK,MAAM,QAAQ,IAAI,SAAS,EAAE;YAChC,MAAM,YAAY,GAAa,QAAQ,CAAC,KAAK,CAC3C,IAAI,CAAC,wBAAwB,EAC7B,CAAC,CAAC,CACH,CAAC;YACF,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE;gBAC7B,SAAS;aACV;YACD,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,GAAG,YAAY,CAAC;YAChC,gDAAgD;YAChD,GAAG,GAAG,GAAG,CAAC,IAAI,EAAE,CAAC;YACjB,KAAK,GAAG,KAAK;iBACV,IAAI,EAAE;iBACN,KAAK,CAAC,OAAO,CAAC;iBACd,IAAI,CAAC,EAAE,CAAC,CAAC;YACZ,IAAI,CAAC,YAAY,CAAC,kBAAkB,CAAC,GAAG,CAAC,EAAE;gBACzC,MAAM,IAAI,KAAK,CACb,aAAa,YAAY,CAAC,2BAA2B,EAAE,CACxD,CAAC;aACH;YACD,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;gBAChC,MAAM,IAAI,KAAK,CACb,eAAe,YAAY,CAAC,2BAA2B,EAAE,CAC1D,CAAC;aACH;YACD,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;SACrB;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;;;;;OAOG;IACK,MAAM,CAAC,KAAK,CAAC,QAAkB,EAAE,aAAuB;QAC9D,IAAI,CAAC,QAAQ,EAAE;YACb,OAAO,aAAa,CAAC;SACtB;QACD,IAAI,CAAC,aAAa,EAAE;YAClB,OAAO,QAAQ,CAAC;SACjB;QACD,OAAO;YACL,IAAI,EAAE,QAAQ,CAAC,IAAI,IAAI,aAAa,CAAC,IAAI;YACzC,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,aAAa,CAAC,MAAM,EAAE,QAAQ,CAAC,MAAM,CAAC;SACjE,CAAC;IACJ,CAAC;IAED;;;;;;OAMG;IACK,MAAM,CAAC,OAAO,CAAC,IAAY;QACjC,OAAO,CACL,IAAI,CAAC,MAAM,IAAI,YAAY,CAAC,UAAU;YACtC,0BAAW,CAAC,iBAAiB,CAAC,IAAI,CAAC,CACpC,CAAC;IACJ,CAAC;IAED;;;;;;OAMG;IACK,MAAM,CAAC,kBAAkB,CAAC,IAAY;QAC5C,OAAO,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IACvD,CAAC;IAED,gBAAgB;IAChB,MAAM,CAAC,KAAK;QACV,YAAY,CAAC,QAAQ,GAAG,YAAY,CAAC,iBAAiB,CACpD,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAC7B,CAAC;QACF,YAAY,CAAC,aAAa,GAAG,YAAY,CAAC,mBAAmB,CAC3D,OAAO,CAAC,GAAG,CAAC,kBAAkB,CAC/B,CAAC;IACJ,CAAC;;AA1KH,oCA2KC;AA1KC,uEAAuE;AAC/C,uBAAU,GAAG,GAAG,CAAC;AAEzC,0DAA0D;AAClC,4BAAe,GAAG,GAAG,CAAC;AAE9C,+DAA+D;AACvC,qCAAwB,GAAG,GAAG,CAAC;AAExC,qBAAQ,GAAG,YAAY,CAAC,iBAAiB,CACtD,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAC7B,CAAC;AACa,0BAAa,GAAG,YAAY,CAAC,mBAAmB,CAC7D,OAAO,CAAC,GAAG,CAAC,kBAAkB,CAC/B,CAAC;AACsB,wCAA2B,GACjD,uEAAuE;IACvE,YAAY,CAAC,UAAU;IACvB,cAAc,CAAC;AACO,wCAA2B,GACjD,oDAAoD;IACpD,YAAY,CAAC,UAAU;IACvB,cAAc,CAAC","sourcesContent":["/**\n * Copyright 2018, OpenCensus Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { StringUtils } from '../internal/string-utils';\nimport { Labels, Resource } from './types';\n\n/**\n * Resource represents a resource, which capture identifying information about\n * the entities for which signals (stats or traces) are reported. It further\n * provides a framework for detection of resource information from the\n * environment and progressive population as signals propagate from the core\n * instrumentation library to a backend's exporter.\n */\nexport class CoreResource {\n  // Type, label keys, and label values should not exceed 256 characters.\n  private static readonly MAX_LENGTH = 255;\n\n  // OC_RESOURCE_LABELS is a comma-separated list of labels.\n  private static readonly COMMA_SEPARATOR = ',';\n\n  // OC_RESOURCE_LABELS contains key value pair separated by '='.\n  private static readonly LABEL_KEY_VALUE_SPLITTER = '=';\n\n  private static ENV_TYPE = CoreResource.parseResourceType(\n    process.env.OC_RESOURCE_TYPE\n  );\n  private static ENV_LABEL_MAP = CoreResource.parseResourceLabels(\n    process.env.OC_RESOURCE_LABELS\n  );\n  private static readonly ERROR_MESSAGE_INVALID_CHARS =\n    'should be a ASCII string with a length greater than 0 and not exceed ' +\n    CoreResource.MAX_LENGTH +\n    ' characters.';\n  private static readonly ERROR_MESSAGE_INVALID_VALUE =\n    'should be a ASCII string with a length not exceed ' +\n    CoreResource.MAX_LENGTH +\n    ' characters.';\n\n  /**\n   * Returns a Resource. This resource information is loaded from the\n   * OC_RESOURCE_TYPE and OC_RESOURCE_LABELS environment variables.\n   *\n   * @returns The resource.\n   */\n  static createFromEnvironmentVariables(): Resource {\n    return { type: CoreResource.ENV_TYPE, labels: CoreResource.ENV_LABEL_MAP };\n  }\n\n  /**\n   * Returns a Resource that runs all input resources sequentially and merges\n   * their results. In case a type of label key is already set, the first set\n   * value takes precedence.\n   *\n   * @param resources The list of the resources.\n   * @returns The resource.\n   */\n  static mergeResources(resources: Resource[]): Resource {\n    if (resources.length === 0) return { type: 'global', labels: {} };\n    let currentResource = resources[0];\n    for (let i = 1; i < resources.length; i++) {\n      currentResource = this.merge(currentResource, resources[i]);\n    }\n    return currentResource;\n  }\n\n  /**\n   * Creates a resource type from the OC_RESOURCE_TYPE environment variable.\n   *\n   * OC_RESOURCE_TYPE: A string that describes the type of the resource\n   * prefixed by a domain namespace, e.g. “kubernetes.io/container”.\n   *\n   * @param rawEnvType The resource type.\n   * @returns The sanitized resource type.\n   */\n  private static parseResourceType(rawEnvType?: string): string | null {\n    if (!rawEnvType) return null;\n    if (!CoreResource.isValidAndNotEmpty(rawEnvType)) {\n      throw new Error(`Type ${CoreResource.ERROR_MESSAGE_INVALID_CHARS}`);\n    }\n    return rawEnvType.trim();\n  }\n\n  /**\n   * Creates a label map from the OC_RESOURCE_LABELS environment variable.\n   *\n   * OC_RESOURCE_LABELS: A comma-separated list of labels describing the\n   * source in more detail, e.g. “key1=val1,key2=val2”. Domain names and paths\n   * are accepted as label keys. Values may be quoted or unquoted in general. If\n   * a value contains whitespaces, =, or \" characters, it must always be quoted.\n   *\n   * @param rawEnvLabels The resource labels as a comma-seperated list\n   * of key/value pairs.\n   * @returns The sanitized resource labels.\n   */\n  private static parseResourceLabels(rawEnvLabels?: string): Labels {\n    if (!rawEnvLabels) return {};\n\n    const labels: Labels = {};\n    const rawLabels: string[] = rawEnvLabels.split(this.COMMA_SEPARATOR, -1);\n    for (const rawLabel of rawLabels) {\n      const keyValuePair: string[] = rawLabel.split(\n        this.LABEL_KEY_VALUE_SPLITTER,\n        -1\n      );\n      if (keyValuePair.length !== 2) {\n        continue;\n      }\n      let [key, value] = keyValuePair;\n      // Leading and trailing whitespaces are trimmed.\n      key = key.trim();\n      value = value\n        .trim()\n        .split('^\"|\"$')\n        .join('');\n      if (!CoreResource.isValidAndNotEmpty(key)) {\n        throw new Error(\n          `Label key ${CoreResource.ERROR_MESSAGE_INVALID_CHARS}`\n        );\n      }\n      if (!CoreResource.isValid(value)) {\n        throw new Error(\n          `Label value ${CoreResource.ERROR_MESSAGE_INVALID_VALUE}`\n        );\n      }\n      labels[key] = value;\n    }\n    return labels;\n  }\n\n  /**\n   * Returns a new, merged Resource by merging two resources. In case of\n   * a collision, first resource takes precedence.\n   *\n   * @param resource The resource object.\n   * @param otherResource The resource object.\n   * @returns A new, merged Resource.\n   */\n  private static merge(resource: Resource, otherResource: Resource): Resource {\n    if (!resource) {\n      return otherResource;\n    }\n    if (!otherResource) {\n      return resource;\n    }\n    return {\n      type: resource.type || otherResource.type,\n      labels: Object.assign({}, otherResource.labels, resource.labels),\n    };\n  }\n\n  /**\n   * Determines whether the given String is a valid printable ASCII string with\n   * a length not exceed MAX_LENGTH characters.\n   *\n   * @param str The String to be validated.\n   * @returns Whether the String is valid.\n   */\n  private static isValid(name: string): boolean {\n    return (\n      name.length <= CoreResource.MAX_LENGTH &&\n      StringUtils.isPrintableString(name)\n    );\n  }\n\n  /**\n   * Determines whether the given String is a valid printable ASCII string with\n   * a length greater than 0 and not exceed MAX_LENGTH characters.\n   *\n   * @param str The String to be validated.\n   * @returns Whether the String is valid and not empty.\n   */\n  private static isValidAndNotEmpty(name: string): boolean {\n    return name.length > 0 && CoreResource.isValid(name);\n  }\n\n  /** TEST_ONLY */\n  static setup() {\n    CoreResource.ENV_TYPE = CoreResource.parseResourceType(\n      process.env.OC_RESOURCE_TYPE\n    );\n    CoreResource.ENV_LABEL_MAP = CoreResource.parseResourceLabels(\n      process.env.OC_RESOURCE_LABELS\n    );\n  }\n}\n"]}